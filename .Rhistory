if (is.infinite(max_v_val)) {
ex <- names(v)[which(is.infinite(v))[1]] # Si hay Inf, excluir la primera
} else {
ex <- names(v)[which.max(v)]
}
# Defensa: Si la variable a excluir ya está en la lista de excluidas
if (ex %in% exc) {
warning("Variable ", ex, " with max VIF already in excluded list. Breaking loop.")
break
}
# Añadir a excluidas y remover de mantenidas
exc <- c(exc, ex)
kept_vars <- kept_vars[!(kept_vars %in% ex)]
}
# --- Recalcular VIFs finales para las variables MANTENIDAS para imprimir ---
final_vif_data <- NULL # Almacenará el data.frame de VIFs finales o un mensaje
kept_df_subset <- x_df[, kept_vars, drop = FALSE] # Dataframe final con variables mantenidas
if (length(kept_vars) > 0) {
# Recalcular VIFs solo si quedan al menos 2 variables
if (length(kept_vars) > 1) {
final_vif_values <- round(calc_vif(kept_df_subset),4)
if (length(final_vif_values) > 0) {
# --- Modificación 2: Corregir formato del data frame de VIFs ---
# Usar los nombres de las variables como nombres de fila y 'VIF' como columna
final_vif_data <- data.frame(VIF = final_vif_values)
# Opcional: Ordenar por VIF
# final_vif_data <- final_vif_data[order(final_vif_data$VIF, decreasing = TRUE),, drop = FALSE]
} else {
final_vif_data <- "Could not calculate VIFs for kept variables (e.g., perfect collinearity remaining or insufficient variables after zero-variance removal)."
}
} else { # Si solo queda una variable
final_vif_data <- "Only one variable kept. VIF calculation not applicable."
}
} else { # Si no queda ninguna variable
final_vif_data <- "No variables kept."
}
# --- Sección de Impresión Corregida ---
cat("--- VIF Filtering Summary ---\n")
cat("VIF filtering completed.\n")
cat("Kept layers:", paste(kept_vars, collapse = ", "), "\n")
cat("Excluded layers:", paste(exc, collapse = ", "), "\n")
# --- Imprimir la matriz de correlación ORIGINAL ---
cat("\nPearson correlation matrix of original data:\n")
# Verificar si es una matriz (significa que se pudo calcular)
if (is.matrix(original_cor_matrix)) {
print(original_cor_matrix) # Usar print() para mostrar la matriz
} else {
# Usar cat() para mostrar el mensaje si no se pudo calcular
cat(original_cor_matrix, "\n")
}
# Imprimir los VIFs finales (formato corregido)
cat("\nFinal VIF values for kept variables:\n")
if (is.data.frame(final_vif_data)) {
print(final_vif_data) # Usar print() para mostrar el data frame de VIFs corregido
} else {
cat(final_vif_data, "\n") # Usar cat() para mostrar el mensaje si no se pudo calcular el data frame
}
cat("----------------------------\n")
# --- Devolver el SpatRaster filtrado ---
if (length(kept_vars) == 0) {
warning("All variables were excluded. Returning an empty SpatRaster.")
return(original_raster[[character(0)]])
}
# Seleccionar las capas del raster original usando los nombres de las variables kept
result_raster <- subset(original_raster, kept_vars)
return(result_raster)
}
tic()
present_climatic_variables <- vif_filter(present_climatic_variables, th = 10)
toc()
present_climatic_variables <- terra::rast(list.files(dir_present_climate_data, "//.tif$", full.names = T))
dir_present_climate_data <- "C:/A_TRABAJO/A_GABRIEL/REPRESENTATIVIDAD/CLIMA_OLD/PRESENTE/"
dir_future_climate_data <- "C:/A_TRABAJO/A_GABRIEL/REPRESENTATIVIDAD/CLIMA_OLD/RCP85_2070/"
present_climatic_variables <- terra::rast(list.files(dir_present_climate_data, "//.tif$", full.names = T))
list.files(dir_present_climate_data, "//.tif$", full.names = T)
present_climatic_variables <- terra::rast(list.files(dir_present_climate_data,  full.names = T))
plot(present_climatic_variables)
resultados <- pa_mh_present_future(
polygon = polygon,
col_name = "ORIG_NAME",
present_climatic_variables = present_climatic_variables,
future_climatic_variables = future_climatic_variables,
study_area = study_area,
th = 0.9,
model = "MARIO",
year = "2070",
dir_output = dir_result,
save_raster = F)
pa_mh_present_future <- function(polygon,
col_name,
present_climatic_variables,
future_climatic_variables,
study_area,
th = 0.9,
model,
year,
dir_output = "output/",
save_raster = TRUE) {
old_warn <- getOption("warn")
options(warn = -1)
on.exit(options(warn = old_warn))
dir_present <- file.path(dir_output, "Present")
dir_future <- file.path(dir_output, "Future")
dir_shared <- file.path(dir_output, "Shared")
dir_charts <- file.path(dir_output, "Charts")
dirs_to_create <- c(dir_present, dir_future, dir_charts, dir_shared)
if (save_raster) {
dirs_to_create <- c(dir_present, dir_future, dir_shared, dir_charts)
} else {
dirs_to_create <- c(dir_shared, dir_charts)
}
sapply(dirs_to_create, function(dir) {
if (!dir.exists(dir)) {
dir.create(dir, recursive = TRUE, showWarnings = FALSE)
}
})
reference_system_check <- terra::crs(present_climatic_variables, describe = TRUE)$code
reference_system <- terra::crs(present_climatic_variables)
if (terra::crs(future_climatic_variables, describe = TRUE)$code != reference_system_check) {
message("Adjusting CRS of future_climatic_variables to match reference system.")
future_climatic_variables <- terra::project(future_climatic_variables, reference_system)
}
if (sf::st_crs(polygon)$epsg != reference_system_check) {
message("Adjusting CRS of polygon to match reference system.")
polygon <- sf::st_transform(polygon, reference_system)
}
if (sf::st_crs(study_area)$epsg != reference_system_check) {
message("Adjusting CRS of study_area to match reference system.")
study_area <- sf::st_transform(study_area, reference_system)
}
message("Starting process")
data_p <- na.omit(terra::as.data.frame(present_climatic_variables, xy = TRUE))
data_p$Period <- "Present"
data_f <- na.omit(terra::as.data.frame(future_climatic_variables, xy = TRUE))
data_f$Period <- "Future"
data_p_f <- rbind(data_p, data_f)
cov_matrix <- cov(data_p_f[, 3:(ncol(data_p_f)-1)], use = "complete.obs")
for(j in 1:nrow(polygon)) {
pol <- polygon[j, ]
pol_name <- as.character(pol[[col_name]])
pol_name <- as.character(tolower(pol_name))
pol_name <- iconv(pol_name, to = 'ASCII//TRANSLIT')
pol_name <- gsub("[^a-z0-9_]+", "_", pol_name)
pol_name <- gsub("__+", "_", pol_name)
pol_name <- gsub("^_|_$", "", pol_name)
message("\nProcessing polygon: ", pol_name, " (", j, " of ", nrow(polygon), ")")
raster_polygon <- terra::mask(terra::crop(present_climatic_variables, pol), pol)
if(all(is.na(terra::values(raster_polygon)))) {
warning("No available data for: ", pol_name, ". Skipping...")
next
}
mu <- terra::global(raster_polygon, "mean", na.rm = TRUE)$mean
calculate_mh <- function(data) {
coords <- data[, 1:2]
climatic_data <- as.matrix(data[, 3:(ncol(data)-1)])
mh_values <- mahalanobis(climatic_data, mu, cov_matrix)
terra::rast(cbind(coords, mh_values), type = "xyz", crs = reference_system)
}
mh_present <- calculate_mh(data_p)
mh_future <- calculate_mh(data_f)
if(save_raster) {
terra::writeRaster(mh_present,
paste0(dir_present, "/MH_PRESENT_", pol_name, ".tif"),
overwrite = TRUE)
terra::writeRaster(mh_future,
paste0(dir_future, "/MH_FUTURE_", model, "_", year, "_", pol_name, ".tif"),
overwrite = TRUE)
}
mh_poly <- terra::mask(mh_present, pol)
th_value <- quantile(terra::values(mh_poly), probs = th, na.rm = TRUE)
if(anyNA(th_value)) {
warning("No threshold was obtained for: ", pol_name, ". Skipping...")
next
}
classify_mh <- function(mh_raster, threshold) {
terra::ifel(mh_raster <= threshold, 1, 0)
}
th_present <- classify_mh(mh_present, th_value)
th_future <- classify_mh(mh_future, th_value)
shared <- th_present * th_future
solo_presente <- th_present - shared
solo_futura <- th_future - shared
raster_final <- shared + (solo_presente * 2) + (solo_futura * 3)
terra::writeRaster(
raster_final,
file.path(dir_output, "Shared", paste0("TH_SHARED_", model, "_", year, "_", pol_name, ".tif")),
overwrite = TRUE
)
raster_final <- terra::as.factor(raster_final)
p <- suppressMessages(ggplot2::ggplot() +
tidyterra::geom_spatraster(data = raster_final) +
ggplot2::geom_sf(data = study_area, color = "gray50", fill = NA, linewidth = 1) +
ggplot2::geom_sf(data = pol, color = "black", fill = NA) +
ggplot2::scale_fill_manual(
name = "Categorías",
values = c(
"0" = "grey90",
"1" = "gold",
"2" = "aquamarine3",
"3" = "coral3"
),
labels = c(
"0" = "Non-representative",
"1" = "Stable representativeness",
"2" = "Present representativeness",
"3" = "Future representativeness"
),
na.value = "transparent",
na.translate = FALSE,
drop = FALSE
) +
ggplot2::ggtitle(pol_name) +
ggplot2::theme_minimal())
ggplot2::ggsave(
filename = file.path(dir_output, "Charts", paste0(pol_name, "_rep_shared.jpeg")),
plot = p,
width = 10,
height = 8,
dpi = 300
)
}
message("\nAll processes were completed")
return(invisible(NULL))
}
resultados <- pa_mh_present_future(
polygon = polygon,
col_name = "ORIG_NAME",
present_climatic_variables = present_climatic_variables,
future_climatic_variables = future_climatic_variables,
study_area = study_area,
th = 0.9,
model = "MARIO",
year = "2070",
dir_output = dir_result,
save_raster = F)
names(future_climatic_variables) <- names(present_climatic_variables)
resultados <- pa_mh_present_future(
polygon = polygon,
col_name = "ORIG_NAME",
present_climatic_variables = present_climatic_variables,
future_climatic_variables = future_climatic_variables,
study_area = study_area,
th = 0.9,
model = "MARIO",
year = "2070",
dir_output = dir_result,
save_raster = F)
dir_present_climate_data <- "C:/A_TRABAJO/A_GABRIEL/REPRESENTATIVIDAD/CLIMA_OLD/PRESENTE/"
dir_future_climate_data <- "C:/A_TRABAJO/A_GABRIEL/REPRESENTATIVIDAD/CLIMA_OLD/RCP85_2070/"
present_climatic_variables <- terra::rast(list.files(dir_present_climate_data, "//.tif$", full.names = T))
library(terra)
library(sf)
library(tictoc)
dir_present_climate_data <- "C:/A_TRABAJO/A_GABRIEL/REPRESENTATIVIDAD/CLIMA_OLD/PRESENTE/"
dir_future_climate_data <- "C:/A_TRABAJO/A_GABRIEL/REPRESENTATIVIDAD/CLIMA_OLD/RCP85_2070/"
present_climatic_variables <- terra::rast(list.files(dir_present_climate_data,  full.names = T))
future_climatic_variables <- terra::rast(list.files(dir_future_climate_data,  full.names = T))
names(future_climatic_variables) <- names(present_climatic_variables)
# Reference system ----
terra::crs(present_climatic_variables)
reference_system <- terra::crs(present_climatic_variables)
##############################################################################################################################
##############################################################################################################################
dir_result <- "C:/A_TRABAJO/A_GABRIEL/REPRESENTATIVIDAD/OLD/TEST_PNAC/"
study_area <- read_sf("C:/A_TRABAJO/A_CLIMAREP_TEST/DATA/Peninsula_Iberica_89.shp")
#study_area <- read_sf("C:/A_TRABAJO/A_CLIMAREP_TEST/DATA/MURCIA.shp")
polygon <- read_sf("C:/A_TRABAJO/A_GABRIEL/REPRESENTATIVIDAD/OLD/TEST_PNAC/national_parks.shp")
study_area <- st_transform(study_area, crs(reference_system))
study_area <- st_make_valid(study_area)
polygon <- st_transform(polygon, crs(reference_system))
polygon <- st_make_valid(polygon)
polygon<- st_intersection(st_crop(polygon, st_bbox(study_area)), study_area)
# Crop raster to study area
present_climatic_variables <-  terra::mask (crop(present_climatic_variables, study_area), study_area)
future_climatic_variables  <-  terra::mask(crop(future_climatic_variables,  study_area), study_area)
resultados <- pa_mh_present_future(
polygon = polygon,
col_name = "ORIG_NAME",
present_climatic_variables = present_climatic_variables,
future_climatic_variables = future_climatic_variables,
study_area = study_area,
th = 0.9,
model = "GFDL",
year = "2070",
dir_output = dir_result,
save_raster = F)
future_climatic_variables  <-  terra::mask(crop(future_climatic_variables,  present_climatic_variables), present_climatic_variables)
future_climatic_variables  <-  terra::mask(terra::crop(future_climatic_variables,  present_climatic_variables), present_climatic_variables)
present_climatic_variables
future_climatic_variables
present_climatic_variables  <-  terra::mask(terra::crop(present_climatic_variables, future_climatic_variables), future_climatic_variables)
library(terra)
library(sf)
library(tictoc)
dir_present_climate_data <- "C:/A_TRABAJO/A_CLIMAREP_TEST/DATA/CLIMA/PRESENT/"
dir_future_climate_data <- "C:/A_TRABAJO/A_CLIMAREP_TEST/DATA/CLIMA/FUTURE/GFDL/"
## Load data ----
present_climatic_variables <- terra::rast(list.files(dir_present_climate_data, "\\.tif$", full.names = T))
# Crear un vector con los nombres de las variables a excluir
exclude_vars <- c("bio8", "bio9", "bio18", "bio19")
#
# # Crear un patrón de expresión regular para excluir estas variables
exclude_pattern <- paste0("bio(", paste(gsub("bio", "", exclude_vars), collapse = "|"), ")")
#
# # Seleccionar las variables deseadas
present_climatic_variables <- subset(present_climatic_variables, grep(exclude_pattern, names(present_climatic_variables), invert = TRUE, value = TRUE))
future_climatic_variables <- terra::rast(list.files(dir_future_climate_data, "\\.tif$", full.names = T))
future_climatic_variables <- subset(future_climatic_variables, grep(exclude_pattern, names(future_climatic_variables), invert = TRUE, value = TRUE))
names(present_climatic_variables) <- c("CHELSA_bio1","CHELSA_bio10","CHELSA_bio11","CHELSA_bio12","CHELSA_bio13","CHELSA_bio14",
"CHELSA_bio15","CHELSA_bio16","CHELSA_bio17","CHELSA_bio2",
"CHELSA_bio3","CHELSA_bio4","CHELSA_bio5","CHELSA_bio6","CHELSA_bio7")
names(future_climatic_variables) <- names(present_climatic_variables)
# Reference system ----
terra::crs(present_climatic_variables)
reference_system <- terra::crs(present_climatic_variables)
##############################################################################################################################
##############################################################################################################################
dir_result <- "C:/A_TRABAJO/A_CLIMAREP_TEST/N2000_RESULTS/"
study_area <- read_sf("C:/A_TRABAJO/A_CLIMAREP_TEST/DATA/Peninsula_Iberica_89.shp")
#study_area <- read_sf("C:/A_TRABAJO/A_CLIMAREP_TEST/DATA/MURCIA.shp")
polygon <- read_sf("C:/A_TRABAJO/A_CLIMAREP_TEST/DATA/NATURA_2000.shp")
# polygon <- filter(polygon, DESIG_ENG %in% c( "Nacional Park"
# ))
polygon <- dplyr::filter(polygon, GIS_AREA >= 10)
study_area <- st_transform(study_area, crs(reference_system))
study_area <- st_make_valid(study_area)
polygon <- st_transform(polygon, crs(reference_system))
polygon <- st_make_valid(polygon)
library(terra)
library(sf)
library(tictoc)
dir_present_climate_data <- "C:/A_TRABAJO/A_CLIMAREP_TEST/DATA/CLIMA/PRESENT/"
dir_future_climate_data <- "C:/A_TRABAJO/A_CLIMAREP_TEST/DATA/CLIMA/FUTURE/GFDL/"
## Load data ----
present_climatic_variables <- terra::rast(list.files(dir_present_climate_data, "\\.tif$", full.names = T))
# Crear un vector con los nombres de las variables a excluir
exclude_vars <- c("bio8", "bio9", "bio18", "bio19")
#
# # Crear un patrón de expresión regular para excluir estas variables
exclude_pattern <- paste0("bio(", paste(gsub("bio", "", exclude_vars), collapse = "|"), ")")
#
# # Seleccionar las variables deseadas
present_climatic_variables <- subset(present_climatic_variables, grep(exclude_pattern, names(present_climatic_variables), invert = TRUE, value = TRUE))
future_climatic_variables <- terra::rast(list.files(dir_future_climate_data, "\\.tif$", full.names = T))
future_climatic_variables <- subset(future_climatic_variables, grep(exclude_pattern, names(future_climatic_variables), invert = TRUE, value = TRUE))
names(present_climatic_variables) <- c("CHELSA_bio1","CHELSA_bio10","CHELSA_bio11","CHELSA_bio12","CHELSA_bio13","CHELSA_bio14",
"CHELSA_bio15","CHELSA_bio16","CHELSA_bio17","CHELSA_bio2",
"CHELSA_bio3","CHELSA_bio4","CHELSA_bio5","CHELSA_bio6","CHELSA_bio7")
names(future_climatic_variables) <- names(present_climatic_variables)
# Reference system ----
terra::crs(present_climatic_variables)
reference_system <- terra::crs(present_climatic_variables)
##############################################################################################################################
##############################################################################################################################
dir_result <- "C:/A_TRABAJO/A_CLIMAREP_TEST/N2000_RESULTS/"
study_area <- read_sf("C:/A_TRABAJO/A_CLIMAREP_TEST/DATA/Peninsula_Iberica_89.shp")
#study_area <- read_sf("C:/A_TRABAJO/A_CLIMAREP_TEST/DATA/MURCIA.shp")
polygon <- read_sf("C:/A_TRABAJO/A_CLIMAREP_TEST/DATA/NATURA_2000.shp")
# polygon <- filter(polygon, DESIG_ENG %in% c( "Nacional Park"
# ))
polygon <- dplyr::filter(polygon, GIS_AREA >= 10)
study_area <- st_transform(study_area, crs(reference_system))
study_area <- st_make_valid(study_area)
polygon <- st_transform(polygon, crs(reference_system))
polygon <- st_make_valid(polygon)
polygon<- st_intersection(st_crop(polygon, st_bbox(study_area)), study_area)
# Crop raster to study area
present_climatic_variables <-  terra::mask (crop(present_climatic_variables, study_area), study_area)
future_climatic_variables  <-  terra::mask(crop(future_climatic_variables,  study_area), study_area)
###########################################
tic()
present_climatic_variables <- vif_filter(present_climatic_variables, th = 10)
vif_filter <- function(x, th = 10) {
# --- Importante: Exigir que el input sea un SpatRaster ---
if (!inherits(x, 'SpatRaster')) {
stop("Input 'x' must be a SpatRaster object to return a filtered raster.")
}
# Almacenar el raster original
original_raster <- x
# Convertir a data frame para el cálculo de VIF
# na.rm=TRUE significa que el cálculo de VIF se hace sobre filas sin NAs
x_df <- terra::as.data.frame(x, na.rm = TRUE)
# Verificar si el dataframe resultante está vacío
if (nrow(x_df) == 0 || ncol(x_df) == 0) {
warning("Data frame is empty after removing NAs. Cannot perform VIF calculation. Returning an empty SpatRaster.")
return(original_raster[[character(0)]])
}
# --- Modificación 1: Calcular y almacenar la matriz de correlación ORIGINAL ---
original_cor_matrix <- NULL
# Solo calcular si hay al menos 2 columnas en el data frame original
if (ncol(x_df) > 1) {
original_cor_matrix <- round(cor(x_df, method = "pearson"), 4)
} else {
# Si solo hay 0 o 1 columna, no se puede calcular la matriz de correlación
original_cor_matrix <- "Correlation matrix not applicable (less than 2 original variables after removing NAs)."
}
# Helper function para calcular VIF values (la versión robusta anterior)
calc_vif <- function(df) {
if (ncol(df) <= 1) {
return(numeric(0))
}
variances <- apply(df, 2, var, na.rm = TRUE)
cols_zero_var <- names(variances[variances < .Machine$double.eps^0.5])
if (length(cols_zero_var) > 0) {
warning("Removing columns with zero or near-zero variance during VIF calculation:", paste(cols_zero_var, collapse = ", "))
df <- df[, !(colnames(df) %in% cols_zero_var), drop = FALSE]
if (ncol(df) <= 1) {
return(numeric(0))
}
}
vif_values <- sapply(1:ncol(df), function(i) {
model <- try(lm(as.formula(paste(names(df)[i], "~ .")), data = df), silent = TRUE)
if (inherits(model, "try-error") || is.null(summary(model)$r.squared) || is.na(summary(model)$r.squared) || summary(model)$r.squared >= 1) {
return(Inf)
}
vif <- 1 / (1 - summary(model)$r.squared)
if (is.infinite(vif)) {
return(Inf)
}
return(vif)
})
names(vif_values) <- colnames(df)
return(vif_values)
}
exc <- character(0) # Variables excluidas
kept_vars <- colnames(x_df) # Variables que se mantienen inicialmente (todos los nombres de columna)
# Filtrado iterativo por VIF
while (length(kept_vars) > 1) {
# Trabajar con el sub-dataframe de las variables aún mantenidas
df_subset <- x_df[, kept_vars, drop = FALSE]
# Calcular VIF para las variables actuales en el sub-dataframe
v <- calc_vif(df_subset)
# Si no se pudieron calcular VIFs o si todas están por debajo del umbral
if (length(v) == 0 || all(v < th)) {
break
}
# Encontrar la variable con el VIF máximo
max_v_val <- max(v, na.rm = TRUE)
if (is.infinite(max_v_val)) {
ex <- names(v)[which(is.infinite(v))[1]] # Si hay Inf, excluir la primera
} else {
ex <- names(v)[which.max(v)]
}
# Defensa: Si la variable a excluir ya está en la lista de excluidas
if (ex %in% exc) {
warning("Variable ", ex, " with max VIF already in excluded list. Breaking loop.")
break
}
# Añadir a excluidas y remover de mantenidas
exc <- c(exc, ex)
kept_vars <- kept_vars[!(kept_vars %in% ex)]
}
# --- Recalcular VIFs finales para las variables MANTENIDAS para imprimir ---
final_vif_data <- NULL # Almacenará el data.frame de VIFs finales o un mensaje
kept_df_subset <- x_df[, kept_vars, drop = FALSE] # Dataframe final con variables mantenidas
if (length(kept_vars) > 0) {
# Recalcular VIFs solo si quedan al menos 2 variables
if (length(kept_vars) > 1) {
final_vif_values <- round(calc_vif(kept_df_subset),4)
if (length(final_vif_values) > 0) {
# --- Modificación 2: Corregir formato del data frame de VIFs ---
# Usar los nombres de las variables como nombres de fila y 'VIF' como columna
final_vif_data <- data.frame(VIF = final_vif_values)
# Opcional: Ordenar por VIF
# final_vif_data <- final_vif_data[order(final_vif_data$VIF, decreasing = TRUE),, drop = FALSE]
} else {
final_vif_data <- "Could not calculate VIFs for kept variables (e.g., perfect collinearity remaining or insufficient variables after zero-variance removal)."
}
} else { # Si solo queda una variable
final_vif_data <- "Only one variable kept. VIF calculation not applicable."
}
} else { # Si no queda ninguna variable
final_vif_data <- "No variables kept."
}
# --- Sección de Impresión Corregida ---
cat("--- VIF Filtering Summary ---\n")
cat("VIF filtering completed.\n")
cat("Kept layers:", paste(kept_vars, collapse = ", "), "\n")
cat("Excluded layers:", paste(exc, collapse = ", "), "\n")
# --- Imprimir la matriz de correlación ORIGINAL ---
cat("\nPearson correlation matrix of original data:\n")
# Verificar si es una matriz (significa que se pudo calcular)
if (is.matrix(original_cor_matrix)) {
print(original_cor_matrix) # Usar print() para mostrar la matriz
} else {
# Usar cat() para mostrar el mensaje si no se pudo calcular
cat(original_cor_matrix, "\n")
}
# Imprimir los VIFs finales (formato corregido)
cat("\nFinal VIF values for kept variables:\n")
if (is.data.frame(final_vif_data)) {
print(final_vif_data) # Usar print() para mostrar el data frame de VIFs corregido
} else {
cat(final_vif_data, "\n") # Usar cat() para mostrar el mensaje si no se pudo calcular el data frame
}
cat("----------------------------\n")
# --- Devolver el SpatRaster filtrado ---
if (length(kept_vars) == 0) {
warning("All variables were excluded. Returning an empty SpatRaster.")
return(original_raster[[character(0)]])
}
# Seleccionar las capas del raster original usando los nombres de las variables kept
result_raster <- subset(original_raster, kept_vars)
return(result_raster)
}
tic()
present_climatic_variables <- vif_filter(present_climatic_variables, th = 10)
toc()
###########################################
future_climatic_variables <- terra::subset(future_climatic_variables, names(future_climatic_variables) %in% names(present_climatic_variables))
polygon[1:100,]
polygon <- polygon[1:100,]
