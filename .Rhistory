warning(
"Removing columns with zero or near-zero variance during VIF calculation: ",
paste(cols_zero_var, collapse = ", ")
)
df <- df[, !(colnames(df) %in% cols_zero_var), drop = FALSE]
if (ncol(df) <= 1) {
return(numeric(0))
}
}
vif_values <- sapply(1:ncol(df), function(i) {
model <- try(stats::lm(as.formula(paste(names(df)[i], "~ .")), data = df), silent = TRUE)
if (inherits(model, "try-error") ||
is.null(summary(model)$r.squared) ||
is.na(summary(model)$r.squared) ||
summary(model)$r.squared >= 1) {
return(Inf)
}
vif <- 1 / (1 - summary(model)$r.squared)
if (is.infinite(vif)) {
return(Inf)
}
return(vif)
})
names(vif_values) <- colnames(df)
return(vif_values)
}
exc <- character(0)
kept_vars <- colnames(x_df)
while (length(kept_vars) > 1) {
df_subset <- x_df[, kept_vars, drop = FALSE]
v <- calc_vif(df_subset)
if (length(v) == 0 || all(v < th)) {
break
}
max_v_val <- max(v, na.rm = TRUE)
if (is.infinite(max_v_val)) {
ex <- names(v)[which(is.infinite(v))[1]]
} else {
ex <- names(v)[which.max(v)]
}
if (ex %in% exc) {
warning("Variable ",
ex,
" with max VIF already in excluded list. Breaking loop.")
break
}
exc <- c(exc, ex)
kept_vars <- kept_vars[!(kept_vars %in% ex)]
}
final_vif_data <- NULL
kept_df_subset <- x_df[, kept_vars, drop = FALSE]
if (length(kept_vars) > 0) {
if (length(kept_vars) > 1) {
final_vif_values <- round(calc_vif(kept_df_subset), 4)
if (length(final_vif_values) > 0) {
final_vif_data <- data.frame(VIF = final_vif_values)
} else {
final_vif_data <- "Could not calculate VIFs for kept variables (e.g., perfect collinearity remaining or insufficient variables after zero-variance removal)."
}
} else {
final_vif_data <- "Only one variable kept. VIF calculation not applicable."
}
} else {
final_vif_data <- "No variables kept."
}
results_summary <- list(
kept_layers = kept_vars,
excluded_layers = exc,
original_correlation_matrix = original_cor_matrix,
final_vif_values = final_vif_data
)
if (length(kept_vars) == 0) {
warning("All variables were excluded. Returning an empty SpatRaster.")
filtered_raster <- original_raster[[character(0)]]
} else {
filtered_raster <- subset(original_raster, kept_vars)
}
message("All processes were completed")
return(list(filtered_raster = filtered_raster, summary = results_summary))
}
library(devtools)
test()
test()
rm(list = c("vif_filter"))
test()
document()
document
document()
test()
check()
document()
check()
document()
check()
document()
check()
document()
test()
test()
test()
document()
check()
build()
document()
build()
library(devtools)
document()
check()
build()
library(devtools)
test()
document()
check()
build()
library(devtools)
library(test)
test()
document()
check()
build()
mh_overlay <- function(folder_path, output_dir = file.path(tempdir(), "ClimaRep_overlay")) {
if (!is.character(folder_path) ||
length(folder_path) != 1 || !dir.exists(folder_path)) {
stop("Parameter 'folder_path' must be a character string and a valid directory.")
}
if (!is.character(output_dir) || length(output_dir) != 1) {
stop("Parameter 'output_dir' must be a single character string.")
}
if (!dir.exists(output_dir)) {
dir.create(output_dir, recursive = TRUE, showWarnings = FALSE)
}
dir_individual_bands <- file.path(output_dir, "Individual_Bands")
if (!dir.exists(dir_individual_bands)) {
dir.create(dir_individual_bands, recursive = TRUE, showWarnings = FALSE)
}
rgb_category_map <- c("Lost" = 2,
"Retained" = 1,
"Novel" = 3)
rgb_channel_names <- c("Lost_Count_R", "Retained_Count_G", "Novel_Count_B")
raster_files <- list.files(folder_path, pattern = "\\.tif$", full.names = TRUE)
if (length(raster_files) == 0) {
warning("No '.tif files' found in the specified folder: ",
folder_path,
". Returning NULL.")
return(invisible(NULL))
}
message(
"Processing ",
length(raster_files),
" rasters from ",
folder_path
)
first_raster <- terra::rast(raster_files[1])
count_rasters_for_rgb <- vector("list", length = length(rgb_category_map))
names(count_rasters_for_rgb) <- names(rgb_category_map)
all_binary_layers <- list()
for (cat_name in names(rgb_category_map)) {
category_value <- rgb_category_map[cat_name]
message("Calculating counts for category: ",
cat_name,
" (value = ",
category_value,
") ")
current_category_binary_layers <- list()
for (i in seq_along(raster_files)) {
file_path <- raster_files[i]
current_raster <- terra::rast(file_path)
binary_layer <- terra::ifel(current_raster == category_value, 1, 0)
current_category_binary_layers[[length(current_category_binary_layers) + 1]] <- binary_layer
}
if (length(current_category_binary_layers) > 0) {
stacked_binary_layers <- terra::rast(current_category_binary_layers)
current_category_sum_raster <- terra::app(stacked_binary_layers, fun =
"sum")
} else {
current_category_sum_raster <- first_raster * 0
}
# Save individual band to its own .tif file
band_filename <- paste0(rgb_channel_names[which(names(rgb_category_map) == cat_name)], ".tif")
terra::writeRaster(current_category_sum_raster,
file.path(dir_individual_bands, band_filename),
overwrite = TRUE,
datatype = "INT2U")
count_rasters_for_rgb[[cat_name]] <- current_category_sum_raster
}
final_rgb_stack <- c(count_rasters_for_rgb[["Lost"]],
count_rasters_for_rgb[["Retained"]],
count_rasters_for_rgb[["Novel"]])
names(final_rgb_stack) <- rgb_channel_names
dir_output_file <- file.path(output_dir, "ClimaRep_overlay.tif")
terra::writeRaster(final_rgb_stack,
dir_output_file,
overwrite = TRUE,
datatype = "INT2U")
message("All processes were completed")
message(paste("Output files saved in: ", output_dir))
return(invisible(final_rgb_stack))
}
mh_overlay(
folder_path = file.path("C:/A_TRABAJO/A_CLIMAREP_TEST/AA_PAPER/RESULTS/N2000/Change_IPSL_250", "Change"),
output_dir = "C:/A_TRABAJO/AQUI")
terra::plot(ClimaRep_overlay)
aa <- mh_overlay(
+   folder_path = file.path("C:/A_TRABAJO/A_CLIMAREP_TEST/AA_PAPER/RESULTS/N2000/Change_IPSL_250", "Change"),
aa <- mh_overlay(
folder_path = file.path("C:/A_TRABAJO/A_CLIMAREP_TEST/AA_PAPER/RESULTS/N2000/Change_IPSL_250", "Change"),
output_dir = "C:/A_TRABAJO/AQUI")
terra::plot(ClimaRep_overlay)
terra::plot(aa)
terra::plotRGB(aa)
terra::plotRGB(aa)
library(devtools)
document()
test()
test()
document()
check()
build()
library(devtools)
document
library(devtools)
document()
document()
test()
check()
document()
test()
check()
document()
test
test()
test()
document()
check()
document()
test()
library(devtools)
document()
test()
check()
build()
document()
test()
check()
document()
check()
document()
check()
build()
build()
documen
library(devtools)
document()
test()
check()
build()
library(devtools)
document()
test()
check()
build()
library(devtools)
test()
document()
check()
build()
library(devtools)
document()
document()
build()
remove.packages("ClimaRep")
document()
build()
library(devtools)
document()
build()
library(devtools)
document()
build()
library(devtools)
document()
build()
library(devtools)
document()
check()
document()
check()
build()
library(devtools)
document()
test()
document()
build()
library(devtools)
document()
test()
document()
build()
library(devtools)
document()
build()
#'    col_name = "name",
#'    present_climate_variables = r_clim_present_filtered,
#'    future_climate_variables = r_clim_future,
#'    study_area = study_area_polygon,
#'    th = 0.95,
#'    model = "ExampleModel",
#'    year = "2070",
#'    dir_output = file.path(tempdir(), "ClimaRepChange"),
#'    save_raw = TRUE)
#' @export
mh_rep_ch <- function(polygon,
col_name,
present_climate_variables,
future_climate_variables,
study_area,
th = 0.95,
model,
year,
dir_output = file.path(tempdir(), "ClimaRep"),
save_raw = FALSE) {
if (!inherits(polygon, "sf"))
stop("Parameter 'polygon' must be an sf object")
if (!is.character(col_name) ||
length(col_name) != 1 || !(col_name %in% names(polygon))) {
stop("Parameter 'col_name' must be a single character string naming a column in 'polygon'")
}
if (!inherits(present_climate_variables, "SpatRaster"))
stop("Parameter 'present_climate_variables' must be a SpatRaster object")
if (!inherits(future_climate_variables, "SpatRaster"))
stop("Parameter 'future_climate_variables' must be a SpatRaster object")
if (!inherits(study_area, "sf"))
stop("Parameter 'study_area' must be an sf object.")
if (!is.numeric(th) || length(th) != 1 || th < 0 || th > 1) {
stop("Parameter 'th' must be a single numeric value between 0 and 1")
}
if (!is.character(model) || length(model) != 1) {
stop("Parameter 'model' must be a single character string")
}
if (!is.character(year) || length(year) != 1) {
stop("Parameter 'year' must be a single character string")
}
if (!is.character(dir_output) || length(dir_output) != 1) {
stop("Parameter 'dir_output' must be a single character string")
}
if (terra::nlyr(present_climate_variables) < 2) {
warning("present_climate_variables has fewer than 2 layers. Mahalanobis distance is typically for multiple variables")
}
if (terra::nlyr(present_climate_variables) != terra::nlyr(future_climate_variables)) {
stop("Number of layers in 'present_climate_variables' and 'future_climate_variables' must be the same")
}
message("Establishing output file structure")
dir_present <- file.path(dir_output, "Mh_Raw_Pre")
dir_future <- file.path(dir_output, "Mh_Raw_Fut")
dir_change <- file.path(dir_output, "Change")
dir_charts <- file.path(dir_output, "Charts")
dirs_to_create <- c(dir_change, dir_charts)
if (save_raw) {
dirs_to_create <- c(dirs_to_create, dir_present, dir_future)
}
sapply(dirs_to_create, function(dir) {
if (!dir.exists(dir)) {
dir.create(dir, recursive = TRUE, showWarnings = FALSE)
}
})
message("Validating and adjusting Coordinate Reference Systems (CRS)")
reference_system <- terra::crs(sf::st_crs(polygon)$wkt)
reference_system_check <- sf::st_crs(polygon)$epsg
if (is.na(reference_system_check) || reference_system_check == "") {
stop("CRS for 'polygon' is undefined. Please set a valid CRS for the polygon")
}
if (terra::crs(present_climate_variables, describe = TRUE)$code != reference_system_check) {
message("Adjusting CRS of present_climate_variables to match the polygon's system")
present_climate_variables <- terra::project(present_climate_variables, reference_system)
}
if (terra::crs(future_climate_variables, describe = TRUE)$code != reference_system_check) {
message("Adjusting CRS of future_climate_variables to match the polygon's system")
future_climate_variables <- terra::project(future_climate_variables, reference_system)
}
if (sf::st_crs(study_area)$epsg != reference_system_check) {
message("Adjusting CRS of study_area to match the polygon's system")
study_area <- sf::st_transform(study_area, reference_system)
}
message("Defining the climate reference space")
present_masked <- terra::mask(terra::crop(present_climate_variables, study_area),
study_area)
future_masked <- terra::mask(terra::crop(future_climate_variables, study_area),
study_area)
data_p_study <- na.omit(terra::as.data.frame(present_masked, xy = TRUE))
data_f_study <- na.omit(terra::as.data.frame(future_masked, xy = TRUE))
if (nrow(data_p_study) == 0 ||
nrow(data_f_study) == 0) {
stop("No valid climate data found within 'study_area' for one or both periods. Cannot calculate combined covariance matrix")
}
climate_data_cols <- 3:(ncol(data_p_study))
data_combined_clim <- rbind(data_p_study[, climate_data_cols], data_f_study[, climate_data_cols])
cov_matrix_pre <- suppressWarnings(cov(data_p_study[, climate_data_cols], use = "complete.obs"))
cov_matrix_prefut <- suppressWarnings(cov(data_combined_clim, use = "complete.obs"))
if (inherits(try(solve(cov_matrix_prefut), silent = TRUE)
, "try-error")) {
stop("Covariance matrix (combined present/future data) is singular (e.g., perfectly correlated or insufficient data). Consider filtering variables 'vif_filter()'")
}
message("Starting per-polygon processing:")
classify_mh <- function(mh_raster, threshold) {
terra::ifel(mh_raster <= threshold, 1, 0)
}
for (j in 1:nrow(polygon)) {
pol <- polygon[j, ]
pol_name <- as.character(pol[[col_name]])
pol_name <- as.character(tolower(pol_name))
pol_name <- iconv(pol_name, to = 'ASCII//TRANSLIT')
pol_name <- gsub("[^a-z0-9_]+", "_", pol_name)
pol_name <- gsub("__+", "_", pol_name)
pol_name <- gsub("^_|_$", "", pol_name)
message("\nProcessing polygon: ",pol_name, " (",j," of ",nrow(polygon),")")
raster_polygon_present <- terra::mask(terra::crop(present_masked, pol), pol)
if (all(is.na(terra::values(raster_polygon_present)))) {
warning("No available data for: ",
pol_name,
" in the present period. Skipping.")
next
}
mu_present_polygon <- terra::global(raster_polygon_present, "mean", na.rm = TRUE)$mean
mh_values_present <- mahalanobis(as.matrix(data_p_study[, climate_data_cols]),
mu_present_polygon,
cov_matrix_pre)
mh_values_future <- mahalanobis(as.matrix(data_f_study[, climate_data_cols]),
mu_present_polygon,
cov_matrix_prefut)
mh_present <- terra::rast(cbind(data_p_study$x, data_p_study$y, mh_values_present),
type = "xyz",
crs = reference_system)
mh_future <- terra::rast(cbind(data_f_study$x, data_f_study$y, mh_values_future),
type = "xyz",
crs = reference_system)
if (save_raw) {
terra::writeRaster(mh_present, file.path(dir_present, paste0("Mh_raw_Pre_", pol_name, ".tif")),
overwrite = TRUE)
terra::writeRaster(mh_future, file.path(dir_future, paste0("Mh_raw_Fut_", model, "_", year, "_", pol_name, ".tif")),
overwrite = TRUE)
}
mh_poly <- terra::mask(mh_present, pol)
th_value <- suppressWarnings(quantile(terra::values(mh_poly),
probs = th,
na.rm = TRUE))
if (anyNA(th_value) || is.infinite(th_value)) {
warning("No valid threshold was obtained for: ",
pol_name,
". Skipping.")
next
}
th_present <- classify_mh(mh_present, th_value)
th_future <- classify_mh(mh_future, th_value)
raster_final <- (th_present * th_future) +
((th_present - (th_present * th_future)) * 2) +
((th_future - (th_present * th_future)) * 3)
terra::writeRaster(raster_final,
file.path(
dir_output,
"Change",
paste0("Th_change_", model, "_", year, "_", pol_name, ".tif")),
overwrite = TRUE)
raster_final_factor <- terra::as.factor(raster_final)
p <- suppressMessages(
ggplot2::ggplot() +
tidyterra::geom_spatraster(data = raster_final_factor) +
ggplot2::geom_sf(
data = study_area,
color = "gray50",
fill = NA,
linewidth = 0.5) +
ggplot2::geom_sf(
data = pol,
color = "black",
fill = NA) +
ggplot2::scale_fill_manual(
name = " ",
values = c(
"0" = "grey90", # Unsuitable
"1" = "aquamarine4", # Stable
"2" = "coral1", # Lost
"3" = "steelblue2"), # Novel
labels = c(
"0" = "Unsuitable",
"1" = "Stable",
"2" = "Lost",
"3" = "Novel"),
na.value = "transparent",
na.translate = FALSE,
drop = FALSE) +
ggplot2::ggtitle(pol_name) +
ggplot2::theme_minimal() +
ggplot2::theme(plot.title = element_text(hjust = 0.5)))
ggplot2::ggsave(
filename = file.path(
dir_output,
"Charts",
paste0(pol_name, "_rep_change.jpeg")
),
plot = p,
width = 10,
height = 10,
dpi = 300)
}
message("All processes were completed")
message(paste("Output files in: ", dir_output))
return(invisible(NULL))
}
library(devtools)
document()
document()
build()
