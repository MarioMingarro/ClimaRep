final_raster = final_raster
)
} else {
result <- list(
variables = remaining_vars,
excluded = exc,
correlationmatrix = if (length(remaining_vars) > 1) cor(x[, remaining_vars], method = "pearson") else NULL,
results = if (length(remaining_vars) > 0) data.frame(Variables = names(v), VIF = v) else NULL
)
}
print(result)
return(result)
}
###########################################
present_climatic_variables <- vif_filter(present_climatic_variables, th = 10)
library(terra)
library(sf)
dir_present_climate_data <- "C:/A_TRABAJO/A_GABRIEL/REPRESENTATIVIDAD/CLIMA/PRESENT/"
dir_future_climate_data <- "C:/A_TRABAJO/A_GABRIEL/REPRESENTATIVIDAD/CLIMA/FUTURE/GFDL/"
dir_result <- "C:/A_TRABAJO/A_GABRIEL/REPRESENTATIVIDAD/PKG/"
#study_area <- read_sf("C:/A_TRABAJO/A_GABRIEL/REPRESENTATIVIDAD/Peninsula_Iberica_89.shp")
study_area <- read_sf("C:/A_TRABAJO/A_GABRIEL/REPRESENTATIVIDAD/MURCIA/MURCIA.shp")
polygon <- read_sf("C:/A_TRABAJO/A_GABRIEL/REPRESENTATIVIDAD/MURCIA/WDPA_MURCIA_89N.shp")
## Load data ----
present_climatic_variables <- terra::rast(list.files(dir_present_climate_data, "\\.tif$", full.names = T))
# Crear un vector con los nombres de las variables a excluir
exclude_vars <- c("bio8", "bio9", "bio18", "bio19")
# Crear un patrón de expresión regular para excluir estas variables
exclude_pattern <- paste0("bio(", paste(gsub("bio", "", exclude_vars), collapse = "|"), ")")
# Seleccionar las variables deseadas
present_climatic_variables <- subset(present_climatic_variables, grep(exclude_pattern, names(present_climatic_variables), invert = TRUE, value = TRUE))
future_climatic_variables <- terra::rast(list.files(dir_future_climate_data, "\\.tif$", full.names = T))
future_climatic_variables <- subset(future_climatic_variables, grep(exclude_pattern, names(future_climatic_variables), invert = TRUE, value = TRUE))
names(present_climatic_variables) <- c("CHELSA_bio1","CHELSA_bio10","CHELSA_bio11","CHELSA_bio12","CHELSA_bio13","CHELSA_bio14",
"CHELSA_bio15","CHELSA_bio16","CHELSA_bio17","CHELSA_bio2",
"CHELSA_bio3","CHELSA_bio4","CHELSA_bio5","CHELSA_bio6","CHELSA_bio7")
names(future_climatic_variables) <- names(present_climatic_variables)
# Reference system ----
terra::crs(present_climatic_variables)
reference_system <-"EPSG:4326"
study_area <- st_transform(study_area, crs(reference_system))
study_area <- st_make_valid(study_area)
polygon <- st_transform(polygon, crs(reference_system))
polygon <- st_make_valid(polygon)
polygon <- st_intersection(st_crop(polygon, st_bbox(study_area)), study_area)
# Crop raster to study area
present_climatic_variables <-  terra::mask (crop(present_climatic_variables, study_area), study_area)
future_climatic_variables  <-  terra::mask(crop(future_climatic_variables,  study_area), study_area)
###########################################
present_climatic_variables <- vif_filter(present_climatic_variables, th = 10)
plot(present_climatic_variables)
present_climatic_filtered <- resultados$final_raster
###########################################
resultados <- vif_filter(present_climatic_variables, th = 10)
library(terra)
library(sf)
dir_present_climate_data <- "C:/A_TRABAJO/A_GABRIEL/REPRESENTATIVIDAD/CLIMA/PRESENT/"
dir_future_climate_data <- "C:/A_TRABAJO/A_GABRIEL/REPRESENTATIVIDAD/CLIMA/FUTURE/GFDL/"
dir_result <- "C:/A_TRABAJO/A_GABRIEL/REPRESENTATIVIDAD/PKG/"
#study_area <- read_sf("C:/A_TRABAJO/A_GABRIEL/REPRESENTATIVIDAD/Peninsula_Iberica_89.shp")
study_area <- read_sf("C:/A_TRABAJO/A_GABRIEL/REPRESENTATIVIDAD/MURCIA/MURCIA.shp")
polygon <- read_sf("C:/A_TRABAJO/A_GABRIEL/REPRESENTATIVIDAD/MURCIA/WDPA_MURCIA_89N.shp")
## Load data ----
present_climatic_variables <- terra::rast(list.files(dir_present_climate_data, "\\.tif$", full.names = T))
# Crear un vector con los nombres de las variables a excluir
exclude_vars <- c("bio8", "bio9", "bio18", "bio19")
# Crear un patrón de expresión regular para excluir estas variables
exclude_pattern <- paste0("bio(", paste(gsub("bio", "", exclude_vars), collapse = "|"), ")")
# Seleccionar las variables deseadas
present_climatic_variables <- subset(present_climatic_variables, grep(exclude_pattern, names(present_climatic_variables), invert = TRUE, value = TRUE))
future_climatic_variables <- terra::rast(list.files(dir_future_climate_data, "\\.tif$", full.names = T))
future_climatic_variables <- subset(future_climatic_variables, grep(exclude_pattern, names(future_climatic_variables), invert = TRUE, value = TRUE))
names(present_climatic_variables) <- c("CHELSA_bio1","CHELSA_bio10","CHELSA_bio11","CHELSA_bio12","CHELSA_bio13","CHELSA_bio14",
"CHELSA_bio15","CHELSA_bio16","CHELSA_bio17","CHELSA_bio2",
"CHELSA_bio3","CHELSA_bio4","CHELSA_bio5","CHELSA_bio6","CHELSA_bio7")
names(future_climatic_variables) <- names(present_climatic_variables)
# Reference system ----
terra::crs(present_climatic_variables)
reference_system <-"EPSG:4326"
study_area <- st_transform(study_area, crs(reference_system))
study_area <- st_make_valid(study_area)
polygon <- st_transform(polygon, crs(reference_system))
polygon <- st_make_valid(polygon)
polygon <- st_intersection(st_crop(polygon, st_bbox(study_area)), study_area)
# Crop raster to study area
present_climatic_variables <-  terra::mask (crop(present_climatic_variables, study_area), study_area)
future_climatic_variables  <-  terra::mask(crop(future_climatic_variables,  study_area), study_area)
###########################################
resultados <- vif_filter(present_climatic_variables, th = 10)
present_climatic_filtered <- resultados$final_raster
plot(present_climatic_filtered)
# Método print para la clase vif_result
print.vif_result <- function(x, ...) {
cat("Resultado de filtrado VIF:\n")
cat("Variables incluidas:", paste(x$variables, collapse=", "), "\n")
cat("Variables excluidas:", paste(x$excluded, collapse=", "), "\n")
if(!is.null(x$vif_values)) {
cat("\nValores VIF finales:\n")
print(data.frame(Variable=names(x$vif_values), VIF=x$vif_values))
}
}
vif_filter <- function(x, th = 10) {
vif_filter <- function(x, th = 10) {
}
vif_filter <- function(x, th = 10) {
vif_filter <- function(x, th = 10) {
vif_filter <- function(x, th = 10) {
vif_filter <- function(x, th = 10) {
#'   VIF is removed. This process repeats until all remaining VIFs are below
#'   the threshold or only one variable remains. VIFs are calculated based on
#'   a data frame derived from the input, removing rows with NA in any relevant column.
#'
#' @importFrom terra as.data.frame ncell rast subset writeRaster
#' @importFrom stats as.formula lm summary cor na.omit
#' @importFrom utils capture.output
#' @importFrom methods inherits
#'
#' @export
vif_filter <- function(x, th = 10, export_dir = NULL) {
# --- 1. Preparación ---
is_raster_input <- inherits(x, 'SpatRaster')
original_input <- x # Keep a copy of the original object
# Convert to data frame and remove NA rows for VIF calculation
if (is_raster_input) {
# Use na.rm = TRUE to remove cells with NA in any layer relevant to this analysis
df_for_vif <- terra::as.data.frame(x, na.rm = TRUE)
} else {
# Assume data frame input is ready, but remove NA rows just in case
df_for_vif <- na.omit(x)
}
# Handle case with no valid data
if (nrow(df_for_vif) == 0 || ncol(df_for_vif) == 0) {
warning("No complete cases or no variables found for VIF calculation. Returning original object with empty results.")
summary_results <- list(
variables = character(0),
excluded = if(ncol(original_input)>0) names(original_input) else colnames(original_input),
correlation_matrix = NULL,
vif_results = data.frame(Variables = if(ncol(original_input)>0) names(original_input) else colnames(original_input), VIF = NA),
threshold = th
)
print(summary_results) # Print summary even on error
return(list(filtered_object = x, summary_results = summary_results))
}
# Store original variable names
original_vars <- colnames(df_for_vif)
df_filtered <- df_for_vif # Working copy for filtering
# Check if enough data points for initial VIF calculation
if (nrow(df_filtered) < ncol(df_filtered) + 1 && ncol(df_filtered) > 1) {
warning(paste0("Fewer data points (", nrow(df_filtered), ") than variables (", ncol(df_filtered), "+1) for initial VIF calculation. VIFs may be unreliable or infinite. Proceeding with caution."))
}
# --- 2. Cálculo y Filtrado Iterativo ---
calc_vif <- function(df) {
if (ncol(df) <= 1) { # VIF not calculated for 0 or 1 variable
return(numeric(0))
}
# Need at least k+1 observations for k predictors
if (nrow(df) < ncol(df) + 1) {
# Return Inf for all variables if not enough data for model fitting
return(setNames(rep(Inf, ncol(df)), colnames(df)))
}
vif_values <- sapply(1:ncol(df), function(i) {
formula_str <- paste(names(df)[i], "~ .")
# Use capture.output to suppress potential warnings from lm model fitting itself
# Suppress also warning about perfect fit (R-squared=1) which makes VIF Inf
model_fit <- tryCatch({
suppressWarnings(lm(as.formula(formula_str), data = df))
}, error = function(e) {
# If lm itself errors out (e.g., perfect collinearity that wasn't caught)
return(NULL)
})
if (is.null(model_fit) || !inherits(model_fit, "lm")) {
return(Inf) # Indicate perfect collinearity or model failure
}
r_squared <- summary(model_fit)$r.squared
if (is.na(r_squared) || r_squared >= 1) {
return(Inf) # VIF is infinite if R-squared is 1
}
vif <- 1 / (1 - r_squared)
return(vif)
})
names(vif_values) <- colnames(df)
return(vif_values)
}
excluded_vars <- character(0)
all_vif_at_decision <- list() # Store VIF for each var when decision is made
# Continue filtering as long as there are variables and max VIF >= threshold
while (ncol(df_filtered) > 1) {
v <- calc_vif(df_filtered)
# If no VIFs calculated (<=1 var) or all are finite and below threshold, stop
if (length(v) == 0 || (all(is.finite(v)) && max(v, na.rm = TRUE) < th)) {
# Store VIFs for the remaining variables
if(length(v) > 0) all_vif_at_decision[names(v)] <- v
break # Exit loop
}
# Find variable with max VIF (prioritize Inf)
if (any(is.infinite(v))) {
var_to_remove <- names(v)[which(is.infinite(v))[1]] # Take the first one if multiple Inf
all_vif_at_decision[[var_to_remove]] <- Inf # Store Inf VIF
} else {
var_to_remove <- names(v)[which.max(v)]
all_vif_at_decision[[var_to_remove]] <- v[var_to_remove] # Store the max VIF
}
# Remove the variable
excluded_vars <- c(excluded_vars, var_to_remove)
df_filtered <- df_filtered[, !(colnames(df_filtered) %in% var_to_remove), drop = FALSE]
# If only one variable remains after removal, store its VIF (0) and break
if (ncol(df_filtered) == 1) {
all_vif_at_decision[[colnames(df_filtered)]] <- 0 # VIF for single variable in this context
break
}
}
# Handle case where loop broke with 0 or 1 variable initially
if (ncol(df_filtered) <= 1 && !(colnames(df_filtered) %in% names(all_vif_at_decision)) && ncol(df_filtered) > 0) {
all_vif_at_decision[[colnames(df_filtered)]] <- 0 # Assign 0 if it was the only variable and loop didn't run/store
}
# --- 3. Recopilar Resultados ---
selected_vars <- colnames(df_filtered)
# Ensure all original variables have an entry in all_vif_at_decision
# Variables that were not processed by calc_vif (e.g., only 1 initially) might be missing.
# Variables perfectly collinear might have caused early errors.
# Let's create the final VIF df ensuring all original names are present.
final_vif_df <- data.frame(Variables = original_vars)
final_vif_df$VIF <- sapply(original_vars, function(var) {
# Get the stored VIF, default to NA if not found (shouldn't happen if logic is perfect, but for safety)
val <- all_vif_at_decision[[var]]
if (is.null(val)) NA else val
})
# Ensure order matches original_vars
final_vif_df <- final_vif_df[match(original_vars, final_vif_df$Variables), ]
correlation_matrix <- if (ncol(df_filtered) > 1) cor(df_filtered, method = "pearson") else NULL
summary_results <- list(
variables = selected_vars,
excluded = excluded_vars,
correlation_matrix = correlation_matrix,
vif_results = final_vif_df, # This is the accurate VIF data frame
threshold = th
)
# --- 4. Exportar Rásteres Seleccionados (si aplica) ---
filtered_object <- NULL # Will store the filtered SpatRaster or data.frame
if (is_raster_input) {
if (length(selected_vars) > 0) {
# Subset the original raster stack using the selected layer names
filtered_object <- terra::subset(original_input, selected_vars)
# Export selected rasters if export_dir is specified
if (!is.null(export_dir)) {
message("Exporting selected raster layers to: ", export_dir)
# Create directory if it doesn't exist
if (!dir.exists(export_dir)) {
dir.create(export_dir, recursive = TRUE)
}
# Loop through layers and export each one
export_success <- TRUE
for (var_name in names(filtered_object)) {
file_path <- file.path(export_dir, paste0(var_name, ".tif"))
single_layer <- terra::subset(filtered_object, var_name) # Select single layer by name
tryCatch({
terra::writeRaster(single_layer, file_path, overwrite = TRUE, gdal=c("COMPRESS=LZW"))
}, error = function(e) {
warning("Failed to export raster layer '", var_name, "' to '", file_path, "': ", e$message)
export_success <- FALSE
})
}
if(export_success) message("Export complete.")
}
} else {
# If no variables selected, filtered_object remains NULL (as initialized)
warning("No variables selected after VIF filtering. No raster object returned.")
}
} else { # Input was a data frame
filtered_object <- df_filtered # df_filtered already contains the selected columns
if (length(selected_vars) == 0) {
warning("No variables selected after VIF filtering. Returning an empty data frame.")
}
}
# --- 5. Imprimir Resumen y Retornar Resultados ---
cat("\n--- VIF Filtering Summary ---\n")
print(summary_results)
cat("-----------------------------\n")
# Return a list containing the filtered object and the summary results
return(list(filtered_object = filtered_object, summary_results = summary_results))
}
library(terra)
library(sf)
dir_present_climate_data <- "C:/A_TRABAJO/A_GABRIEL/REPRESENTATIVIDAD/CLIMA/PRESENT/"
dir_future_climate_data <- "C:/A_TRABAJO/A_GABRIEL/REPRESENTATIVIDAD/CLIMA/FUTURE/GFDL/"
dir_result <- "C:/A_TRABAJO/A_GABRIEL/REPRESENTATIVIDAD/PKG/"
#study_area <- read_sf("C:/A_TRABAJO/A_GABRIEL/REPRESENTATIVIDAD/Peninsula_Iberica_89.shp")
study_area <- read_sf("C:/A_TRABAJO/A_GABRIEL/REPRESENTATIVIDAD/MURCIA/MURCIA.shp")
polygon <- read_sf("C:/A_TRABAJO/A_GABRIEL/REPRESENTATIVIDAD/MURCIA/WDPA_MURCIA_89N.shp")
## Load data ----
present_climatic_variables <- terra::rast(list.files(dir_present_climate_data, "\\.tif$", full.names = T))
# Crear un vector con los nombres de las variables a excluir
exclude_vars <- c("bio8", "bio9", "bio18", "bio19")
# Crear un patrón de expresión regular para excluir estas variables
exclude_pattern <- paste0("bio(", paste(gsub("bio", "", exclude_vars), collapse = "|"), ")")
# Seleccionar las variables deseadas
present_climatic_variables <- subset(present_climatic_variables, grep(exclude_pattern, names(present_climatic_variables), invert = TRUE, value = TRUE))
future_climatic_variables <- terra::rast(list.files(dir_future_climate_data, "\\.tif$", full.names = T))
future_climatic_variables <- subset(future_climatic_variables, grep(exclude_pattern, names(future_climatic_variables), invert = TRUE, value = TRUE))
names(present_climatic_variables) <- c("CHELSA_bio1","CHELSA_bio10","CHELSA_bio11","CHELSA_bio12","CHELSA_bio13","CHELSA_bio14",
"CHELSA_bio15","CHELSA_bio16","CHELSA_bio17","CHELSA_bio2",
"CHELSA_bio3","CHELSA_bio4","CHELSA_bio5","CHELSA_bio6","CHELSA_bio7")
names(future_climatic_variables) <- names(present_climatic_variables)
# Reference system ----
terra::crs(present_climatic_variables)
reference_system <-"EPSG:4326"
study_area <- st_transform(study_area, crs(reference_system))
study_area <- st_make_valid(study_area)
polygon <- st_transform(polygon, crs(reference_system))
polygon <- st_make_valid(polygon)
polygon <- st_intersection(st_crop(polygon, st_bbox(study_area)), study_area)
# Crop raster to study area
present_climatic_variables <-  terra::mask (crop(present_climatic_variables, study_area), study_area)
future_climatic_variables  <-  terra::mask(crop(future_climatic_variables,  study_area), study_area)
###########################################
resultados <- vif_filter(present_climatic_variables, th = 10)
pa_mh_present_future <- function(
present_climatic_variables,
future_climatic_variables,
polygon,
output_dir = "results",
model = "NULL",
year = "2070",
th = 0.9,
reference_system = "EPSG:4326" ,
study_area = NULL) {
# Crear directorios de salida (usando R base)
dirs_to_create <- file.path(output_dir, c("present", "future", "charts"))
for (dir in dirs_to_create) {
if (!dir.exists(dir)) dir.create(dir, recursive = TRUE)
}
# Función para preparar datos (sin dplyr)
prepare_data <- function(raster_data, period) {
df <- as.data.frame(raster_data, xy = TRUE)
df <- df[complete.cases(df), ]
df <- cbind(df[, 1:2], Period = period, df[, 3:ncol(df)])
return(df)
}
data_present <- prepare_data(present_climatic_variables, "Present")
data_future <- prepare_data(future_climatic_variables, "Future")
# Función para calcular distancia Mahalanobis (base R)
calculate_mh <- function(data, polygon_data) {
polygon_mask <- mask(crop(present_climatic_variables, polygon_data), polygon_data)
polygon_df <- as.data.frame(polygon_mask, xy = TRUE)
polygon_df <- polygon_df[complete.cases(polygon_df), ]
mahalanobis(
as.matrix(data[, 4:ncol(data)]),
colMeans(polygon_df[, 3:ncol(polygon_df)]),
cov(data[, 4:ncol(data)]),
inverted = FALSE
)
}
# Procesar cada polígono
process_polygon <- function(j) {
pol <- polygon[j, ]
name <- polygon$NAME[j]
# Presente
mh_present <- calculate_mh(data_present, pol)
mh_df_present <- cbind(data_present[, 1:3], mh = mh_present)
mh_raster_present <- rast(mh_df_present[, c(1, 2, 4)], crs = reference_system)
# Calcular umbral
points_present <- as.points(mh_raster_present)
points_present_sf <- sf::st_as_sf(points_present)
points_inside <- sf::st_intersection(points_present_sf, pol)
th_value <- quantile(points_inside$mh, probs = th, na.rm = TRUE)
# Aplicar umbral
points_present_sf$th <- as.numeric(points_present_sf$mh <= th_value)
raster_th_present <- create_threshold_raster(points_present_sf, mh_raster_present)
# Futuro
combined_data <- rbind(data_present, data_future)
mh_future <- calculate_mh(combined_data, pol)
mh_df_future <- cbind(combined_data[, 1:3], mh = mh_future)
# Filtrar solo futuro (base R en lugar de dplyr)
mh_df_future <- mh_df_future[mh_df_future$Period == "Future", ]
mh_raster_future <- rast(mh_df_future[, c(1, 2, 4)], crs = reference_system)
# Aplicar umbral a futuro
points_future <- as.points(mh_raster_future)
points_future_sf <- sf::st_as_sf(points_future)
points_future_sf$th <- as.numeric(points_future_sf$mh <= th_value)
raster_th_future <- create_threshold_raster(points_future_sf, mh_raster_future)
# Guardar resultados futuros
writeRaster(
mh_raster_future,
file.path(output_dir, "future", paste0("MH_", model, "_", year, "_", name, ".tif")),
overwrite = TRUE
)
# Análisis comparativo
compare_scenarios(raster_th_present, raster_th_future, pol, name, output_dir)
# Análisis de distancia
distance_analysis(points_present_sf, points_future_sf, pol, name, output_dir, model, year)
}
# Función auxiliar para crear raster de umbral
create_threshold_raster <- function(points_sf, template_raster) {
res <- res(template_raster)
bbox <- ext(template_raster)
raster_template <- rast(
ext = bbox,
nrows = round((bbox[4] - bbox[3]) / res[2]),
ncols = round((bbox[2] - bbox[1]) / res[1])
)
rasterized <- rasterize(vect(points_sf), raster_template, field = "th")
crs(rasterized) <- crs(template_raster)
return(rasterized)
}
# Función para comparar escenarios (requiere ggplot2)
compare_scenarios <- function(raster_present, raster_future, pol, name, output_dir) {
shared <- raster_present * raster_future
only_present <- (raster_present == 1) * (raster_future == 0)
only_future <- (raster_present == 0) * (raster_future == 1)
combined <- shared + (only_present * 2) + (only_future * 3)
combined_factor <- as.factor(combined)
# Gráfico mínimo (se mantiene ggplot2 para calidad de visualización)
plot <- ggplot() +
geom_spatraster(data = combined_factor) +
geom_sf(data = study_area, color = "gray50", fill = NA, linewidth = 1.5) +
geom_sf(data = pol, color = "black", fill = NA) +
scale_fill_manual(
values = c("0" = "grey90", "1" = "gold", "2" = "aquamarine3", "3" = "coral3"),
labels = c("Non-representativeness", "Stable", "Present only", "Future only"),
na.value = "transparent"
) +
coord_sf() +
theme_minimal() +
labs(title = name, fill = "")
png(file.path(output_dir, "charts", paste0(name, "_rep_shared.png")),
width = 1000, height = 800)
print(plot)
dev.off()
writeRaster(
combined,
file.path(output_dir, "future", paste0("TH_MH_PRESENT_", model, "_", year, "_", name, ".tif")),
overwrite = TRUE
)
}
# Función para análisis de distancia (base R)
distance_analysis <- function(points_present, points_future, pol, name, output_dir, model, year) {
# Calcular distancias mínimas
calc_min_distance <- function(points) {
dist_matrix <- sf::st_distance(points, pol)
apply(dist_matrix, 1, min) / 1000  # Convertir a km
}
points_present$dist <- round(calc_min_distance(points_present), 0)
points_future$dist <- round(calc_min_distance(points_future), 0)
# Agregar coordenadas
coords <- sf::st_coordinates(points_present)
points_present <- cbind(as.data.frame(points_present), coords)
coords <- sf::st_coordinates(points_future)
points_future <- cbind(as.data.frame(points_future), coords)
# Calcular estadísticas por distancia (base R)
calculate_stats <- function(points, suffix) {
points <- points[!is.na(points$dist), ]
stats <- aggregate(th ~ dist, data = points,
FUN = function(x) c(
n_total = length(x),
n_zeros = sum(x == 0),
n_ones = sum(x == 1),
pct_zeros = mean(x == 0) * 100,
pct_ones = mean(x == 1) * 100
))
stats <- cbind(stats[1], as.data.frame(stats[[2]]))
names(stats) <- paste0(names(stats), "_", suffix)
return(stats)
}
stats_present <- calculate_stats(points_present, "p")
stats_future <- calculate_stats(points_future, "f")
# Combinar resultados
combined_stats <- merge(stats_present, stats_future, by.x = "dist_p", by.y = "dist_f")
names(combined_stats)[1] <- "dist"
# Calcular acumulados
combined_stats$ones_p_accum <- cumsum(combined_stats$n_ones_p)
combined_stats$ones_f_accum <- cumsum(combined_stats$n_ones_f)
# Gráfico mínimo (base R)
png(file.path(output_dir, "charts", paste0(name, "_scenarios_difference.png")),
width = 1000, height = 800)
plot(combined_stats$dist, combined_stats$ones_p_accum, type = "l", col = "aquamarine3",
lwd = 2, xlab = "Distance (km)", ylab = "Cumulative representative cells",
main = paste(name, year, model, sep = " - "))
lines(combined_stats$dist, combined_stats$ones_f_accum, col = "coral3", lwd = 2)
abline(h = max(combined_stats$ones_p_accum), lty = 2, lwd = 1.5)
legend("bottomright", legend = c("Present", "Future"),
col = c("aquamarine3", "coral3"), lwd = 2)
dev.off()
}
# Procesar todos los polígonos
for (j in seq_len(nrow(polygon))) {
process_polygon(j)
}
}
###########################################
future_climatic_variables <- terra::subset(future_climatic_variables, names(future_climatic_variables) %in% present_climatic_variables$variables)
###########################################
present_climatic_variables <- vif_filter(present_climatic_variables, th = 10)
###########################################
future_climatic_variables <- terra::subset(future_climatic_variables, names(future_climatic_variables) %in% present_climatic_variables$variables)
###########################################
future_climatic_variables <- terra::subset(future_climatic_variables, names(future_climatic_variables) %in% names(present_climatic_variables))
names(present_climatic_variables)
present_climatic_variables
names(present_climatic_variables$filtered_object)
###########################################
future_climatic_variables <- terra::subset(future_climatic_variables, names(future_climatic_variables) %in% names(present_climatic_variables$filtered_object))
kk <- polygon[5,]
pp <- pa_mh_present_future(
present_climatic_variables,
future_climatic_variables,
kk,
output_dir = "results",
model = "kkdvk",
year = "2070",
th = 0.9,
reference_system = "EPSG:4326" ,
study_area = NULL)
