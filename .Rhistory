nrow(polygon),
")")
raster_polygon_present <- terra::mask(terra::crop(present_climate_variables, pol), pol)
if (all(is.na(terra::values(raster_polygon_present)))) {
warning("No available data for: ",
pol_name,
" in the present period. Skipping...")
next
}
mu_present_polygon <- terra::global(raster_polygon_present, "mean", na.rm = TRUE)$mean
mh_values_present <- mahalanobis(as.matrix(full_data_present_clim),
mu_present_polygon,
cov_matrix)
mh_values_future <- mahalanobis(as.matrix(full_data_future_clim),
mu_present_polygon,
cov_matrix)
mh_present_full <- terra::rast(
cbind(full_data_present_coords, mh_values_present),
type = "xyz",
crs = terra::crs(present_climate_variables)
)
mh_future_full <- terra::rast(
cbind(full_data_future_coords, mh_values_future),
type = "xyz",
crs = terra::crs(future_climate_variables)
)
mh_present <- terra::mask(mh_present_full, study_area)
mh_future <- terra::mask(mh_future_full, study_area)
if (save_raw) {
terra::writeRaster(mh_present, file.path(
dir_present,
paste0("MahalanobisRaw_Pre_", pol_name, ".tif")
), overwrite = TRUE)
terra::writeRaster(mh_future, file.path(
dir_future,
paste0(
"MahalanobisRaw_Fut_",
model,
"_",
year,
"_",
pol_name,
".tif"
)
), overwrite = TRUE)
}
mh_poly_for_th <- terra::mask(mh_present_full, pol)
th_value <- quantile(terra::values(mh_poly_for_th),
probs = th,
na.rm = TRUE)
if (anyNA(th_value) || is.infinite(th_value)) {
warning("No valid threshold was obtained for: ",
pol_name,
". Skipping...")
next
}
classify_mh <- function(mh_raster, threshold) {
terra::ifel(mh_raster <= threshold, 1, 0)
}
th_present <- classify_mh(mh_present, th_value)
th_future <- classify_mh(mh_future, th_value)
raster_final <- (th_present * th_future) +
((th_present - (th_present * th_future)) * 2) +
((th_future - (th_present * th_future)) * 3)
terra::writeRaster(raster_final,
file.path(
dir_output,
"Change",
paste0("TH_change_", model, "_", year, "_", pol_name, ".tif")
),
overwrite = TRUE)
raster_final_factor <- terra::as.factor(raster_final)
p <- suppressMessages(
ggplot2::ggplot() +
tidyterra::geom_spatraster(data = raster_final_factor) +
ggplot2::geom_sf(
data = study_area,
color = "gray50",
fill = NA,
linewidth = 1
) +
ggplot2::geom_sf(
data = pol,
color = "black",
fill = NA
) +
ggplot2::scale_fill_manual(
name = " ",
values = c(
"0" = "grey90",
# Non-represented
"1" = "aquamarine4",
# Retained
"2" = "coral1",
# Lost
"3" = "aquamarine2"     # Novel
),
labels = c(
"0" = "Non-represented",
"1" = "Retained",
"2" = "Lost",
"3" = "Novel"
),
na.value = "transparent",
na.translate = FALSE,
drop = FALSE
) +
ggplot2::ggtitle(pol_name) +
ggplot2::theme_minimal() +
ggplot2::theme(plot.title = element_text(hjust = 0.5))
)
ggplot2::ggsave(
filename = file.path(
dir_output,
"Charts",
paste0(pol_name, "_rep_change.jpeg")
),
plot = p,
width = 10,
height = 8,
dpi = 300
)
}
message("All processes were completed")
cat(paste("Output files in: ", dir_output, "\n"))
return(invisible(NULL))
}
output_mh_rep_ch <- mh_rep_ch(
polygon = polygons,
col_name = "name",
present_climate_variables = r_clim_present_filtered,
future_climate_variables = r_clim_future,
study_area = study_area_polygon,
th = 0.95,
model = "ExampleModel",
year = "2070",
dir_output = output_dir,
save_raw = TRUE)
#'    present_climate_variables = r_clim_present_filtered,
#'    future_climate_variables = r_clim_future,
#'    study_area = study_area_polygon,
#'    th = 0.95,
#'    model = "ExampleModel",
#'    year = "2070",
#'    dir_output = file.path(tempdir(), "ClimaRepOutput"),
#'    save_raw = TRUE)
#' }
#' @export
mh_rep_ch <- function(polygon,
col_name,
present_climate_variables,
future_climate_variables,
study_area,
th = 0.95,
model,
year,
dir_output = file.path(tempdir(), "ClimaRep"),
save_raw = FALSE) {
old_warn <- getOption("warn")
options(warn = -1)
on.exit(options(warn = old_warn))
if (!inherits(polygon, "sf"))
stop("Parameter 'polygon' must be an sf object.")
if (!is.character(col_name) ||
length(col_name) != 1 || !(col_name %in% names(polygon))) {
stop("Parameter 'col_name' must be a single character string naming a column in 'polygon'.")
}
if (!inherits(present_climate_variables, "SpatRaster"))
stop("Parameter 'present_climate_variables' must be a SpatRaster object.")
if (!inherits(future_climate_variables, "SpatRaster"))
stop("Parameter 'future_climate_variables' must be a SpatRaster object.")
if (!inherits(study_area, "sf"))
stop("Parameter 'study_area' must be an sf object.")
if (!is.numeric(th) || length(th) != 1 || th < 0 || th > 1) {
stop("Parameter 'th' must be a single numeric value between 0 and 1.")
}
if (!is.character(model) || length(model) != 1) {
stop("Parameter 'model' must be a single character string.")
}
if (!is.character(year) || length(year) != 1) {
stop("Parameter 'year' must be a single character string.")
}
if (!is.character(dir_output) || length(dir_output) != 1) {
stop("Parameter 'dir_output' must be a single character string.")
}
if (terra::nlyr(present_climate_variables) < 2) {
warning(
"present_climate_variables has fewer than 2 layers. Mahalanobis distance is typically for multiple variables. Proceeding with single variable analysis if applicable."
)
}
if (terra::nlyr(present_climate_variables) != terra::nlyr(future_climate_variables)) {
stop(
"Number of layers in 'present_climate_variables' and 'future_climate_variables' must be the same."
)
}
message("Validating CRS and spatial alignment of inputs...")
ref_crs <- terra::crs(present_climate_variables, describe = TRUE)$code
if (is.na(ref_crs) || ref_crs == "") {
stop("CRS for 'present_climate_variables' is undefined. Please set a valid CRS.")
}
if (terra::crs(future_climate_variables, describe = TRUE)$code != ref_crs) {
stop(
"CRS mismatch: 'future_climate_variables' must have the same CRS as 'present_climate_variables'."
)
}
if (sf::st_crs(polygon)$epsg != ref_crs) {
stop("CRS mismatch: 'polygon' must have the same CRS as 'present_climate_variables'.")
}
if (sf::st_crs(study_area)$epsg != ref_crs) {
stop("CRS mismatch: 'study_area' must have the same CRS as 'present_climate_variables'.")
}
dir_present <- file.path(dir_output, "Mh_Raw_Pre")
dir_future <- file.path(dir_output, "Mh_Raw_Fut")
dir_change <- file.path(dir_output, "Change")
dir_charts <- file.path(dir_output, "Charts")
dirs_to_create <- c(dir_change, dir_charts)
if (save_raw) {
dirs_to_create <- c(dirs_to_create, dir_present, dir_future)
}
sapply(dirs_to_create, function(dir) {
if (!dir.exists(dir)) {
dir.create(dir, recursive = TRUE, showWarnings = FALSE)
}
})
message("Starting process")
present_study_area_masked <- terra::mask(terra::crop(present_climate_variables, study_area),
study_area)
future_study_area_masked <- terra::mask(terra::crop(future_climate_variables, study_area),
study_area)
data_p_study <- na.omit(terra::as.data.frame(present_study_area_masked, xy = TRUE))
data_f_study <- na.omit(terra::as.data.frame(future_study_area_masked, xy = TRUE))
if (nrow(data_p_study) == 0 || nrow(data_f_study) == 0) {
stop(
"No valid climate data found within 'study_area' for one or both periods. Cannot calculate combined covariance matrix."
)
}
climate_var_names <- names(present_climate_variables)
data_p_study_clim <- data_p_study[, climate_var_names, drop = FALSE]
data_f_study_clim <- data_f_study[, climate_var_names, drop = FALSE]
if (ncol(data_p_study_clim) < 2) {
stop(
"Not enough climate variables (layers) to calculate a multivariate Mahalanobis distance. Need at least 2 layers."
)
}
data_combined_clim <- rbind(data_p_study_clim, data_f_study_clim)
cov_matrix <- cov(data_combined_clim, use = "complete.obs")
if (inherits(try(solve(cov_matrix), silent = TRUE)
, "try-error")) {
stop(
"Covariance matrix (calculated from combined present/future study area data) is singular. This can happen if variables are perfectly correlated or there's insufficient unique data points. Consider filtering collinear variables or checking data quality within the study area."
)
}
full_data_present <- na.omit(terra::as.data.frame(present_climate_variables, xy = TRUE))
full_data_future <- na.omit(terra::as.data.frame(future_climate_variables, xy = TRUE))
full_data_present_clim <- full_data_present[, climate_var_names, drop = FALSE]
full_data_future_clim <- full_data_future[, climate_var_names, drop = FALSE]
full_data_present_coords <- full_data_present[, c("x", "y")]
full_data_future_coords <- full_data_future[, c("x", "y")]
for (j in 1:nrow(polygon)) {
pol <- polygon[j, ]
pol_name <- as.character(pol[[col_name]])
pol_name <- as.character(tolower(pol_name))
pol_name <- iconv(pol_name, to = 'ASCII//TRANSLIT')
pol_name <- gsub("[^a-z0-9_]+", "_", pol_name)
pol_name <- gsub("__+", "_", pol_name)
pol_name <- gsub("^_|_$", "", pol_name)
message("\nProcessing polygon: ",
pol_name,
" (",
j,
" of ",
nrow(polygon),
")")
raster_polygon_present <- terra::mask(terra::crop(present_climate_variables, pol), pol)
if (all(is.na(terra::values(raster_polygon_present)))) {
warning("No available data for: ",
pol_name,
" in the present period. Skipping...")
next
}
mu_present_polygon <- terra::global(raster_polygon_present, "mean", na.rm = TRUE)$mean
mh_values_present <- mahalanobis(as.matrix(full_data_present_clim),
mu_present_polygon,
cov_matrix)
mh_values_future <- mahalanobis(as.matrix(full_data_future_clim),
mu_present_polygon,
cov_matrix)
mh_present_full <- terra::rast(
cbind(full_data_present_coords, mh_values_present),
type = "xyz",
crs = terra::crs(present_climate_variables)
)
mh_future_full <- terra::rast(
cbind(full_data_future_coords, mh_values_future),
type = "xyz",
crs = terra::crs(future_climate_variables)
)
mh_present <- terra::mask(mh_present_full, study_area)
mh_future <- terra::mask(mh_future_full, study_area)
if (save_raw) {
terra::writeRaster(mh_present, file.path(
dir_present,
paste0("MahalanobisRaw_Pre_", pol_name, ".tif")
), overwrite = TRUE)
terra::writeRaster(mh_future, file.path(
dir_future,
paste0(
"MahalanobisRaw_Fut_",
model,
"_",
year,
"_",
pol_name,
".tif"
)
), overwrite = TRUE)
}
mh_poly_for_th <- terra::mask(mh_present_full, pol)
th_value <- quantile(terra::values(mh_poly_for_th),
probs = th,
na.rm = TRUE)
if (anyNA(th_value) || is.infinite(th_value)) {
warning("No valid threshold was obtained for: ",
pol_name,
". Skipping...")
next
}
classify_mh <- function(mh_raster, threshold) {
terra::ifel(mh_raster <= threshold, 1, 0)
}
th_present <- classify_mh(mh_present, th_value)
th_future <- classify_mh(mh_future, th_value)
raster_final <- (th_present * th_future) +
((th_present - (th_present * th_future)) * 2) +
((th_future - (th_present * th_future)) * 3)
terra::writeRaster(raster_final,
file.path(
dir_output,
"Change",
paste0("TH_change_", model, "_", year, "_", pol_name, ".tif")
),
overwrite = TRUE)
raster_final_factor <- terra::as.factor(raster_final)
p <- suppressMessages(
ggplot2::ggplot() +
tidyterra::geom_spatraster(data = raster_final_factor) +
ggplot2::geom_sf(
data = study_area,
color = "gray50",
fill = NA,
linewidth = 1
) +
ggplot2::geom_sf(
data = pol,
color = "black",
fill = NA
) +
ggplot2::scale_fill_manual(
name = " ",
values = c(
"0" = "grey90",
# Non-represented
"1" = "aquamarine4",
# Retained
"2" = "coral1",
# Lost
"3" = "aquamarine2"     # Novel
),
labels = c(
"0" = "Non-represented",
"1" = "Retained",
"2" = "Lost",
"3" = "Novel"
),
na.value = "transparent",
na.translate = FALSE,
drop = FALSE
) +
ggplot2::ggtitle(pol_name) +
ggplot2::theme_minimal() +
ggplot2::theme(plot.title = element_text(hjust = 0.5))
)
ggplot2::ggsave(
filename = file.path(
dir_output,
"Charts",
paste0(pol_name, "_rep_change.jpeg")
),
plot = p,
width = 10,
height = 8,
dpi = 300
)
}
message("All processes were completed")
cat(paste("Output files in: ", dir_output, "\n"))
return(invisible(NULL))
}
output_mh_rep_ch <- mh_rep_ch(
polygon = polygons,
col_name = "name",
present_climate_variables = r_clim_present_filtered,
future_climate_variables = r_clim_future,
study_area = study_area_polygon,
th = 0.95,
model = "ExampleModel",
year = "2070",
dir_output = output_dir,
save_raw = TRUE)
document()
test()
document()
test()
check()
Sys.getenv("TZ")
Sys.setenv(TZ='UTC')
devtools::check()
document()
test()
Sys.setenv(TZ='UTC')
devtools::check()
document()
test()
document()
test()
Sys.setenv(TZ='UTC')
library(devtools)
document()
test()
check()
Sys.time()
Sys.time()
# 1. Regenera la documentación (esto actualizará los archivos .Rd)
devtools::document()
# 2. Obtén la lista de todos los archivos del paquete que pueden tener el problema
# (Excluye la carpeta .git, ya que Git gestiona sus propios tiempos internos)
package_files <- list.files(
path = ".",
all.files = TRUE,
recursive = TRUE,
full.names = TRUE,
include.dirs = FALSE
)
# Filtra archivos que no necesitamos tocar o que son de .git
package_files <- package_files[!grepl("^./\\.git/", package_files)]
package_files <- package_files[!grepl("\\.Rproj$", package_files)] # Excluir archivos .Rproj
# 3. Itera y actualiza la marca de tiempo de cada archivo
current_time_for_touch <- Sys.time() # Usa una única marca de tiempo para consistencia
for (f in package_files) {
# Solo actualiza si el archivo existe y es un archivo (no un directorio)
if (file.exists(f) && !file.info(f)$isdir) {
Sys.setFileTime(f, current_time_for_touch)
}
}
message("Marcas de tiempo de TODOS los archivos del paquete actualizadas a: ", current_time_for_touch)
devtools::check()
Sys.setenv(TZ='Europe/Madrid')
# 1. Regenera la documentación primero (esto actualizará los .Rd)
devtools::document()
# 2. Obtén la lista de todos los archivos del paquete que pueden tener el problema
package_files <- list.files(
path = ".",
all.files = TRUE,
recursive = TRUE,
full.names = TRUE,
include.dirs = FALSE
)
# Filtra archivos que no necesitamos tocar o que son de .git o el .Rproj
package_files <- package_files[!grepl("^./\\.git/", package_files)]
package_files <- package_files[!grepl("\\.Rproj$", package_files)]
# Importante: No filtres 'LICENSE' ahora, queremos tocarlo explícitamente.
# Ya deberías haber movido o renombrado 'LICENSE.md'.
# 3. Usa una única marca de tiempo para consistencia
current_time_for_touch <- Sys.time()
message("Actualizando marcas de tiempo a: ", current_time_for_touch)
for (f in package_files) {
if (file.exists(f) && !file.info(f)$isdir) {
Sys.setFileTime(f, current_time_for_touch)
# message("  Actualizado: ", f) # Opcional: para ver qué archivos se tocan
}
}
# 4. Toca explícitamente el archivo LICENSE (sin extensión)
if (file.exists("LICENSE") && !file.info("LICENSE")$isdir) {
Sys.setFileTime("LICENSE", current_time_for_touch)
message("Marca de tiempo de LICENSE actualizada.")
} else {
warning("El archivo LICENSE (sin extensión) no se encontró en la raíz del paquete.")
}
devtools::document()
devtools::check()
usethis::edit_r_environ()
# 1. Regenera la documentación primero (esto actualizará los .Rd)
devtools::document()
Sys.time(
)
devtools::check()
devtools::document()
devtools::check()
devtools::document()
devtools::check()
devtools::document()
devtools::check()
usethis::edit_r_environ()
devtools::document()
devtools::check()
library(devtools)
devtools::document()
devtools::check()
devtools::document()
devtools::test()
devtools::check()
devtools::build()
