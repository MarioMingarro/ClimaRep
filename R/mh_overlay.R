#' @title Overlay Mahalanobis-based Climate Representativeness Classifications
#'
#' @description Combines multiple single-layer GeoTIFF rasters, typically outputs from `mh_rep` or `mh_rep_ch`
#' for different input polygons, into a single three-layered `SpatRaster` specifically designed for RGB visualization.
#' The output layers consistently represent counts for 'Lost' (Red channel), 'Retained' (Green channel),
#' and 'Novel' (Blue channel) categories across all input rasters.
#' This function handles inputs from both `mh_rep` (which primarily contains 'Retained' areas) and
#' `mh_rep_ch` (which includes 'Retained', 'Lost', and 'Novel' areas) by counting the presence of
#' each relevant category (1, 2, 3). If a category is not present in the input rasters, its corresponding
#' output layer will contain zeros.
#'
#' @param folder_path `character`. The path to the directory containing the classification
#'   rasters (`.tif`) generated by `mh_rep` or `mh_rep_ch`. These rasters should primarily
#'   contain the categories: `1` (Retained/Represented), `2` (Lost), and `3` (Novel).
#'   Category `0` (Non-represented) will be ignored for the RGB output.
#' @param add_to_environment `logical`. If `TRUE`, the resulting three-layered RGB `SpatRaster` object
#'   will be assigned to a variable named `climarep_rgb` in the global R environment.
#'   Defaults to `TRUE`.
#'
#' @return Invisibly returns the resulting three-layered `SpatRaster` object. This object has layers
#'   representing the cumulative counts for 'Lost' (first layer), 'Retained' (second layer),
#'   and 'Novel' (third layer) categories, designed for direct RGB plotting.
#'   If `add_to_environment` is `TRUE`, the `SpatRaster` is also made available as `climarep_rgb`
#'   in the global environment. Returns `NULL` if no valid rasters are found or processed.
#'
#' @details
#' This function streamlines the aggregation of climate representativeness classifications for
#' visual analysis in an RGB composite. It is designed to work seamlessly with outputs from both
#' `mh_rep` (which yields only 'Retained' or 'Represented' areas, coded as `1`) and
#' `mh_rep_ch` (which yields 'Retained' (`1`), 'Lost' (`2`), and 'Novel' (`3`) areas).
#'
#' For each of the three key categories (Lost, Retained, Novel), the function:
#' \enumerate{
#'   \item Identifies and reads all `.tif` files within the `folder_path`.
#'   \item For every input raster, it creates a binary layer: `1` if the cell's value matches
#'         the target category (e.g., `2` for 'Lost'), and `0` otherwise.
#'   \item Sums these binary layers across all input rasters to generate a cumulative count
#'         for that specific category at each grid cell.
#' }
#'
#' The three resulting count layers (Lost, Retained, Novel) are then consistently stacked
#' in the following order:
#' \itemize{
#'   \item **First layer (Red): Cumulative count of 'Lost'.**
#'   \item **Second layer (Green): Cumulative count of 'Retained'.**
#'   \item **Third layer (Blue): Cumulative count of 'Novel'.**
#' }
#' This fixed order ensures that the output `SpatRaster` is immediately ready for direct
#' RGB visualization using `terra::plotRGB()`, where the color mixtures will intuitively reflect
#' the spatial agreement of these change types across the input polygons.
#'
#' The output `SpatRaster` contains raw counts. While `terra::plotRGB()` often handles
#' stretching for visualization, users might normalize these counts manually (e.g., to 0-255)
#' for finer control over visual contrast.
#'
#' @importFrom terra rast ifel app writeRaster nlyr values
#' @importFrom utils packageVersion
#'
#' @examples
#' \dontrun{
#' mh_overlay(folder_path = file.path(tempdir(), "Change"),
#'            output_filename = "combined_category_counts.tif",
#'            category_values = c(1, 2, 3),
#'            add_to_environment = TRUE)
#' terra::plot(climarep_img)
#' @export
mh_overlay <- function(folder_path, add_to_environment = TRUE) {
  if (!is.character(folder_path) || length(folder_path) != 1 || !dir.exists(folder_path)) {
    stop("Parameter 'folder_path' must be a single character string and a valid directory.")
  }
  if (!is.logical(add_to_environment) || length(add_to_environment) != 1) {
    stop("Parameter 'add_to_environment' must be a single logical value (TRUE/FALSE).")
  }
  rgb_category_map <- c(
    "Lost" = 2,
    "Retained" = 1,
    "Novel" = 3
  )
  rgb_channel_names <- c("Lost_Count_R", "Retained_Count_G", "Novel_Count_B")
  raster_files <- list.files(folder_path, pattern = "\\.tif$", full.names = TRUE)
    if (length(raster_files) == 0) {
    warning("No .tif files found in the specified folder: ", folder_path, ". Returning NULL.")
    return(invisible(NULL))
  }
    message("Processing ", length(raster_files), " classification rasters from ", folder_path, "...")

  first_raster <- terra::rast(raster_files[1])
  count_rasters_for_rgb <- vector("list", length = length(rgb_category_map))
  names(count_rasters_for_rgb) <- names(rgb_category_map)
  for (cat_name in names(rgb_category_map)) {
    category_value <- rgb_category_map[cat_name]
    message("Calculating counts for category: ", cat_name, " (value = ", category_value, ")...")
    current_category_sum_raster <- first_raster * 0
    for (file_path in raster_files) {
      current_raster <- terra::rast(file_path)
      if (!terra::compareGeom(first_raster, current_raster, res=TRUE, extent=TRUE, crs=TRUE)) {
        warning(paste0("Geometry mismatch for ", basename(file_path), ". Skipping this file. All input rasters must be aligned."))
        next
      }
      binary_layer <- terra::ifel(current_raster == category_value, 1, 0)
      current_category_sum_raster <- current_category_sum_raster + binary_layer
    }
    count_rasters_for_rgb[[cat_name]] <- current_category_sum_raster
  }
  final_rgb_stack <- c(
    count_rasters_for_rgb[["Lost"]],    # Red
    count_rasters_for_rgb[["Retained"]], # Green
    count_rasters_for_rgb[["Novel"]]     # Blue
  )
  names(final_rgb_stack) <- rgb_channel_names

  message("Finished processing. Three-layered RGB-ordered SpatRaster created.")
  if (add_to_environment) {
    assign("climarep_rgb", final_rgb_stack, envir = .GlobalEnv)
    message("Resulting SpatRaster assigned to 'climarep_rgb' in your global environment.")
  }
  return(invisible(final_rgb_stack))
}
