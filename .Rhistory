cat("Excluded layers:", paste(exc, collapse = ", "), "\n")
# --- Imprimir la matriz de correlación ORIGINAL ---
cat("\nPearson correlation matrix of original data:\n")
# Verificar si es una matriz (significa que se pudo calcular)
if (is.matrix(original_cor_matrix)) {
print(original_cor_matrix) # Usar print() para mostrar la matriz
} else {
# Usar cat() para mostrar el mensaje si no se pudo calcular
cat(original_cor_matrix, "\n")
}
# Imprimir los VIFs finales (formato corregido)
cat("\nFinal VIF values for kept variables:\n")
if (is.data.frame(final_vif_data)) {
print(final_vif_data) # Usar print() para mostrar el data frame de VIFs corregido
} else {
cat(final_vif_data, "\n") # Usar cat() para mostrar el mensaje si no se pudo calcular el data frame
}
cat("----------------------------\n")
# --- Devolver el SpatRaster filtrado ---
if (length(kept_vars) == 0) {
warning("All variables were excluded. Returning an empty SpatRaster.")
return(original_raster[[character(0)]])
}
# Seleccionar las capas del raster original usando los nombres de las variables kept
result_raster <- subset(original_raster, kept_vars)
return(result_raster)
}
tic()
kk <- vif_filter(present_climatic_variables, th = 10)
toc()
plot(present_climatic_variables)
plot(kk)
###########################################
future_climatic_variables <- terra::subset(future_climatic_variables, names(future_climatic_variables) %in% names(present_climatic_variables$filtered_object))
present_climatic_variables <- vif_filter(present_climatic_variables, th = 10)
###########################################
future_climatic_variables <- terra::subset(future_climatic_variables, names(future_climatic_variables) %in% names(present_climatic_variables$filtered_object))
names(present_climatic_variables$filtered_object))
names(present_climatic_variables$filtered_object)
names(present_climatic_variables)
names(future_climatic_variables)
###########################################
future_climatic_variables <- terra::subset(future_climatic_variables, names(future_climatic_variables) %in% names(present_climatic_variables))
library(ggplot2)
library(terra)
library(sf)
library(tidyterra)
pa_mh_present_future <- function(
present_climatic_variables,
future_climatic_variables,
polygon,
output_dir = "results",
model = "NULL",
year = "2070",
th = 0.9,
reference_system = "EPSG:4326" ,
study_area = NULL) {
# Crear directorios de salida (usando R base)
dirs_to_create <- file.path(output_dir, c("present", "future", "charts"))
for (dir in dirs_to_create) {
if (!dir.exists(dir)) dir.create(dir, recursive = TRUE)
}
# Función para preparar datos (sin dplyr)
prepare_data <- function(raster_data, period) {
df <- as.data.frame(raster_data, xy = TRUE)
df <- df[complete.cases(df), ]
df <- cbind(df[, 1:2], Period = period, df[, 3:ncol(df)])
return(df)
}
data_present <- prepare_data(present_climatic_variables, "Present")
data_future <- prepare_data(future_climatic_variables, "Future")
# Función para calcular distancia Mahalanobis (base R)
calculate_mh <- function(data, polygon_data) {
polygon_mask <- mask(crop(present_climatic_variables, polygon_data), polygon_data)
polygon_df <- as.data.frame(polygon_mask, xy = TRUE)
polygon_df <- polygon_df[complete.cases(polygon_df), ]
mahalanobis(
as.matrix(data[, 4:ncol(data)]),
colMeans(polygon_df[, 3:ncol(polygon_df)]),
cov(data[, 4:ncol(data)]),
inverted = FALSE
)
}
# Procesar cada polígono
process_polygon <- function(j) {
pol <- polygon[j, ]
name <- polygon$NAME[j]
# Presente
mh_present <- calculate_mh(data_present, pol)
mh_df_present <- cbind(data_present[, 1:3], mh = mh_present)
mh_raster_present <- rast(mh_df_present[, c(1, 2, 4)], crs = reference_system)
# Calcular umbral
points_present <- as.points(mh_raster_present)
points_present_sf <- sf::st_as_sf(points_present)
points_inside <- sf::st_intersection(points_present_sf, pol)
th_value <- quantile(points_inside$mh, probs = th, na.rm = TRUE)
# Aplicar umbral
points_present_sf$th <- as.numeric(points_present_sf$mh <= th_value)
raster_th_present <- create_threshold_raster(points_present_sf, mh_raster_present)
# Futuro
combined_data <- rbind(data_present, data_future)
mh_future <- calculate_mh(combined_data, pol)
mh_df_future <- cbind(combined_data[, 1:3], mh = mh_future)
# Filtrar solo futuro (base R en lugar de dplyr)
mh_df_future <- mh_df_future[mh_df_future$Period == "Future", ]
mh_raster_future <- rast(mh_df_future[, c(1, 2, 4)], crs = reference_system)
# Aplicar umbral a futuro
points_future <- as.points(mh_raster_future)
points_future_sf <- sf::st_as_sf(points_future)
points_future_sf$th <- as.numeric(points_future_sf$mh <= th_value)
raster_th_future <- create_threshold_raster(points_future_sf, mh_raster_future)
# Guardar resultados futuros
writeRaster(
mh_raster_future,
file.path(output_dir, "future", paste0("MH_", model, "_", year, "_", name, ".tif")),
overwrite = TRUE
)
# Análisis comparativo
compare_scenarios(raster_th_present, raster_th_future, pol, name, output_dir)
# Análisis de distancia
distance_analysis(points_present_sf, points_future_sf, pol, name, output_dir, model, year)
}
# Función auxiliar para crear raster de umbral
create_threshold_raster <- function(points_sf, template_raster) {
res <- res(template_raster)
bbox <- ext(template_raster)
raster_template <- rast(
ext = bbox,
nrows = round((bbox[4] - bbox[3]) / res[2]),
ncols = round((bbox[2] - bbox[1]) / res[1])
)
rasterized <- rasterize(vect(points_sf), raster_template, field = "th")
crs(rasterized) <- crs(template_raster)
return(rasterized)
}
# Función para comparar escenarios (requiere ggplot2)
compare_scenarios <- function(raster_present, raster_future, pol, name, output_dir) {
shared <- raster_present * raster_future
only_present <- (raster_present == 1) * (raster_future == 0)
only_future <- (raster_present == 0) * (raster_future == 1)
combined <- shared + (only_present * 2) + (only_future * 3)
combined_factor <- as.factor(combined)
# Gráfico mínimo (se mantiene ggplot2 para calidad de visualización)
plot <- ggplot() +
geom_spatraster(data = combined_factor) +
geom_sf(data = study_area, color = "gray50", fill = NA, linewidth = 1.5) +
geom_sf(data = pol, color = "black", fill = NA) +
scale_fill_manual(
values = c("0" = "grey90", "1" = "gold", "2" = "aquamarine3", "3" = "coral3"),
labels = c("Non-representativeness", "Stable", "Present only", "Future only"),
na.value = "transparent"
) +
coord_sf() +
theme_minimal() +
labs(title = name, fill = "")
png(file.path(output_dir, "charts", paste0(name, "_rep_shared.png")),
width = 1000, height = 800)
print(plot)
dev.off()
writeRaster(
combined,
file.path(output_dir, "future", paste0("TH_MH_PRESENT_", model, "_", year, "_", name, ".tif")),
overwrite = TRUE
)
}
# Función para análisis de distancia (base R)
distance_analysis <- function(points_present, points_future, pol, name, output_dir, model, year) {
# Calcular distancias mínimas
calc_min_distance <- function(points) {
dist_matrix <- sf::st_distance(points, pol)
apply(dist_matrix, 1, min) / 1000  # Convertir a km
}
points_present$dist <- round(calc_min_distance(points_present), 0)
points_future$dist <- round(calc_min_distance(points_future), 0)
# Agregar coordenadas
coords <- sf::st_coordinates(points_present)
points_present <- cbind(as.data.frame(points_present), coords)
coords <- sf::st_coordinates(points_future)
points_future <- cbind(as.data.frame(points_future), coords)
# Calcular estadísticas por distancia (base R)
calculate_stats <- function(points, suffix) {
points <- points[!is.na(points$dist), ]
stats <- aggregate(th ~ dist, data = points,
FUN = function(x) c(
n_total = length(x),
n_zeros = sum(x == 0),
n_ones = sum(x == 1),
pct_zeros = mean(x == 0) * 100,
pct_ones = mean(x == 1) * 100
))
stats <- cbind(stats[1], as.data.frame(stats[[2]]))
names(stats) <- paste0(names(stats), "_", suffix)
return(stats)
}
stats_present <- calculate_stats(points_present, "p")
stats_future <- calculate_stats(points_future, "f")
# Combinar resultados
combined_stats <- merge(stats_present, stats_future, by.x = "dist_p", by.y = "dist_f")
names(combined_stats)[1] <- "dist"
# Calcular acumulados
combined_stats$ones_p_accum <- cumsum(combined_stats$n_ones_p)
combined_stats$ones_f_accum <- cumsum(combined_stats$n_ones_f)
# Gráfico mínimo (base R)
png(file.path(output_dir, "charts", paste0(name, "_scenarios_difference.png")),
width = 1000, height = 800)
plot(combined_stats$dist, combined_stats$ones_p_accum, type = "l", col = "aquamarine3",
lwd = 2, xlab = "Distance (km)", ylab = "Cumulative representative cells",
main = paste(name, year, model, sep = " - "))
lines(combined_stats$dist, combined_stats$ones_f_accum, col = "coral3", lwd = 2)
abline(h = max(combined_stats$ones_p_accum), lty = 2, lwd = 1.5)
legend("bottomright", legend = c("Present", "Future"),
col = c("aquamarine3", "coral3"), lwd = 2)
dev.off()
}
# Procesar todos los polígonos
for (j in seq_len(nrow(polygon))) {
process_polygon(j)
}
}
pp <- pa_mh_present_future(
present_climatic_variables,
future_climatic_variables,
polygon,
output_dir = "results",
model = "kkdvk",
year = "2070",
th = 0.9,
reference_system = "EPSG:4326" ,
study_area = NULL)
pp <- pa_mh_present_future(
present_climatic_variables,
future_climatic_variables,
polygon,
output_dir = dir_result,
model = "kkdvk",
year = "2070",
th = 0.9,
reference_system = "EPSG:4326" ,
study_area = NULL)
#'   s <- rast(list(r, 2*r + 0.1, r + 0.5, -r))
#'   names(s) <- c("layer1", "layer2", "layer3", "layer4")
#'   result_raster <- vif_filter(s, th = 5)
#'   print(result_raster)
#' }
#'
#' @importFrom terra as.data.frame
#' @importFrom stats as.formula lm summary cor
#'
#' @export
vif_filter <- function(x, th = 10) {
calc_vif <- function(df) {
if (ncol(df) == 0) {
return(numeric(0))
}
vif_values <- sapply(1:ncol(df), function(i) {
formula <- as.formula(paste(names(df)[i], "~ ."))
model <- lm(formula, data = df)
return(1 / (1 - summary(model)$r.squared))
})
names(vif_values) <- colnames(df)
return(vif_values)
}
if (inherits(x, 'SpatRaster')) {
original <- x
x <- terra::as.data.frame(x, na.rm = TRUE)
}
exc <- character(0)
while (ncol(x) > 0) {
v <- calc_vif(x)
if (length(v) == 0 || max(v) < th) break
ex <- names(v)[which.max(v)]
exc <- c(exc, ex)
x <- x[, !(colnames(x) %in% ex), drop = FALSE]
return(terra::subset(original, exc))
}
result <- list(
variables = colnames(x),
excluded = exc,
correlationmatrix = if (ncol(x) > 1) cor(x, method = "pearson") else NULL,
results = data.frame(Variables = names(v), VIF = v)
)
print(result)
return(result)
}
library(terra)
library(sf)
library(tictoc)
dir_present_climate_data <- "C:/A_TRABAJO/A_CLIMAREP_TEST/DATA/CLIMA/PRESENT/"
dir_future_climate_data <- "C:/A_TRABAJO/A_CLIMAREP_TEST/DATA/CLIMA/FUTURE/GFDL/"
dir_result <- "C:/A_TRABAJO/A_CLIMAREP_TEST/RESULTS/"
#study_area <- read_sf("C:/A_TRABAJO/A_GABRIEL/REPRESENTATIVIDAD/Peninsula_Iberica_89.shp")
study_area <- read_sf("C:/A_TRABAJO/A_CLIMAREP_TEST/DATA/MURCIA.shp")
polygon <- read_sf("C:/A_TRABAJO/A_CLIMAREP_TEST/DATA/PAS_murcia.shp")
## Load data ----
present_climatic_variables <- terra::rast(list.files(dir_present_climate_data, "\\.tif$", full.names = T))
# Crear un vector con los nombres de las variables a excluir
exclude_vars <- c("bio8", "bio9", "bio18", "bio19")
#
# # Crear un patrón de expresión regular para excluir estas variables
exclude_pattern <- paste0("bio(", paste(gsub("bio", "", exclude_vars), collapse = "|"), ")")
#
# # Seleccionar las variables deseadas
present_climatic_variables <- subset(present_climatic_variables, grep(exclude_pattern, names(present_climatic_variables), invert = TRUE, value = TRUE))
future_climatic_variables <- terra::rast(list.files(dir_future_climate_data, "\\.tif$", full.names = T))
future_climatic_variables <- subset(future_climatic_variables, grep(exclude_pattern, names(future_climatic_variables), invert = TRUE, value = TRUE))
names(present_climatic_variables) <- c("CHELSA_bio1","CHELSA_bio10","CHELSA_bio11","CHELSA_bio12","CHELSA_bio13","CHELSA_bio14",
"CHELSA_bio15","CHELSA_bio16","CHELSA_bio17","CHELSA_bio2",
"CHELSA_bio3","CHELSA_bio4","CHELSA_bio5","CHELSA_bio6","CHELSA_bio7")
names(future_climatic_variables) <- names(present_climatic_variables)
# Reference system ----
terra::crs(present_climatic_variables)
reference_system <-"EPSG:4326"
study_area <- st_transform(study_area, crs(reference_system))
study_area <- st_make_valid(study_area)
polygon <- st_transform(polygon, crs(reference_system))
polygon <- st_make_valid(polygon)
polygon <- st_intersection(st_crop(polygon, st_bbox(study_area)), study_area)
# Crop raster to study area
present_climatic_variables <-  terra::mask (crop(present_climatic_variables, study_area), study_area)
future_climatic_variables  <-  terra::mask(crop(future_climatic_variables,  study_area), study_area)
###########################################
tic()
present_climatic_variables <- vif_filter(present_climatic_variables, th = 10)
toc()
###########################################
future_climatic_variables <- terra::subset(future_climatic_variables, names(future_climatic_variables) %in% names(present_climatic_variables))
pa_mh_present_future <- function(
present_climatic_variables,
future_climatic_variables,
polygon,
output_dir = "results",
model = "NULL",
year = "2070",
th = 0.9,
reference_system = "EPSG:4326" ,
study_area = NULL) {
# Crear directorios de salida (usando R base)
dirs_to_create <- file.path(output_dir, c("present", "future", "charts"))
for (dir in dirs_to_create) {
if (!dir.exists(dir)) dir.create(dir, recursive = TRUE)
}
# Función para preparar datos (sin dplyr)
prepare_data <- function(raster_data, period) {
df <- as.data.frame(raster_data, xy = TRUE)
df <- df[complete.cases(df), ]
df <- cbind(df[, 1:2], Period = period, df[, 3:ncol(df)])
return(df)
}
data_present <- prepare_data(present_climatic_variables, "Present")
data_future <- prepare_data(future_climatic_variables, "Future")
# Función para calcular distancia Mahalanobis (base R)
calculate_mh <- function(data, polygon_data) {
polygon_mask <- mask(crop(present_climatic_variables, polygon_data), polygon_data)
polygon_df <- as.data.frame(polygon_mask, xy = TRUE)
polygon_df <- polygon_df[complete.cases(polygon_df), ]
mahalanobis(
as.matrix(data[, 4:ncol(data)]),
colMeans(polygon_df[, 3:ncol(polygon_df)]),
cov(data[, 4:ncol(data)]),
inverted = FALSE
)
}
# Procesar cada polígono
process_polygon <- function(j) {
pol <- polygon[j, ]
name <- polygon$NAME[j]
# Presente
mh_present <- calculate_mh(data_present, pol)
mh_df_present <- cbind(data_present[, 1:3], mh = mh_present)
mh_raster_present <- rast(mh_df_present[, c(1, 2, 4)], crs = reference_system)
# Calcular umbral
points_present <- as.points(mh_raster_present)
points_present_sf <- sf::st_as_sf(points_present)
points_inside <- sf::st_intersection(points_present_sf, pol)
th_value <- quantile(points_inside$mh, probs = th, na.rm = TRUE)
# Aplicar umbral
points_present_sf$th <- as.numeric(points_present_sf$mh <= th_value)
raster_th_present <- create_threshold_raster(points_present_sf, mh_raster_present)
# Futuro
combined_data <- rbind(data_present, data_future)
mh_future <- calculate_mh(combined_data, pol)
mh_df_future <- cbind(combined_data[, 1:3], mh = mh_future)
# Filtrar solo futuro (base R en lugar de dplyr)
mh_df_future <- mh_df_future[mh_df_future$Period == "Future", ]
mh_raster_future <- rast(mh_df_future[, c(1, 2, 4)], crs = reference_system)
# Aplicar umbral a futuro
points_future <- as.points(mh_raster_future)
points_future_sf <- sf::st_as_sf(points_future)
points_future_sf$th <- as.numeric(points_future_sf$mh <= th_value)
raster_th_future <- create_threshold_raster(points_future_sf, mh_raster_future)
# Guardar resultados futuros
writeRaster(
mh_raster_future,
file.path(output_dir, "future", paste0("MH_", model, "_", year, "_", name, ".tif")),
overwrite = TRUE
)
# Análisis comparativo
compare_scenarios(raster_th_present, raster_th_future, pol, name, output_dir)
# Análisis de distancia
distance_analysis(points_present_sf, points_future_sf, pol, name, output_dir, model, year)
}
# Función auxiliar para crear raster de umbral
create_threshold_raster <- function(points_sf, template_raster) {
res <- res(template_raster)
bbox <- ext(template_raster)
raster_template <- rast(
ext = bbox,
nrows = round((bbox[4] - bbox[3]) / res[2]),
ncols = round((bbox[2] - bbox[1]) / res[1])
)
rasterized <- rasterize(vect(points_sf), raster_template, field = "th")
crs(rasterized) <- crs(template_raster)
return(rasterized)
}
# Función para comparar escenarios (requiere ggplot2)
compare_scenarios <- function(raster_present, raster_future, pol, name, output_dir) {
shared <- raster_present * raster_future
only_present <- (raster_present == 1) * (raster_future == 0)
only_future <- (raster_present == 0) * (raster_future == 1)
combined <- shared + (only_present * 2) + (only_future * 3)
combined_factor <- as.factor(combined)
# Gráfico mínimo (se mantiene ggplot2 para calidad de visualización)
plot <- ggplot() +
geom_spatraster(data = combined_factor) +
geom_sf(data = study_area, color = "gray50", fill = NA, linewidth = 1.5) +
geom_sf(data = pol, color = "black", fill = NA) +
scale_fill_manual(
values = c("0" = "grey90", "1" = "gold", "2" = "aquamarine3", "3" = "coral3"),
labels = c("Non-representativeness", "Stable", "Present only", "Future only"),
na.value = "transparent"
) +
coord_sf() +
theme_minimal() +
labs(title = name, fill = "")
png(file.path(output_dir, "charts", paste0(name, "_rep_shared.png")),
width = 1000, height = 800)
print(plot)
dev.off()
writeRaster(
combined,
file.path(output_dir, "future", paste0("TH_MH_PRESENT_", model, "_", year, "_", name, ".tif")),
overwrite = TRUE
)
}
# Función para análisis de distancia (base R)
distance_analysis <- function(points_present, points_future, pol, name, output_dir, model, year) {
# Calcular distancias mínimas
calc_min_distance <- function(points) {
dist_matrix <- sf::st_distance(points, pol)
apply(dist_matrix, 1, min) / 1000  # Convertir a km
}
points_present$dist <- round(calc_min_distance(points_present), 0)
points_future$dist <- round(calc_min_distance(points_future), 0)
# Agregar coordenadas
coords <- sf::st_coordinates(points_present)
points_present <- cbind(as.data.frame(points_present), coords)
coords <- sf::st_coordinates(points_future)
points_future <- cbind(as.data.frame(points_future), coords)
# Calcular estadísticas por distancia (base R)
calculate_stats <- function(points, suffix) {
points <- points[!is.na(points$dist), ]
stats <- aggregate(th ~ dist, data = points,
FUN = function(x) c(
n_total = length(x),
n_zeros = sum(x == 0),
n_ones = sum(x == 1),
pct_zeros = mean(x == 0) * 100,
pct_ones = mean(x == 1) * 100
))
stats <- cbind(stats[1], as.data.frame(stats[[2]]))
names(stats) <- paste0(names(stats), "_", suffix)
return(stats)
}
stats_present <- calculate_stats(points_present, "p")
stats_future <- calculate_stats(points_future, "f")
# Combinar resultados
combined_stats <- merge(stats_present, stats_future, by.x = "dist_p", by.y = "dist_f")
names(combined_stats)[1] <- "dist"
# Calcular acumulados
combined_stats$ones_p_accum <- cumsum(combined_stats$n_ones_p)
combined_stats$ones_f_accum <- cumsum(combined_stats$n_ones_f)
# Gráfico mínimo (base R)
png(file.path(output_dir, "charts", paste0(name, "_scenarios_difference.png")),
width = 1000, height = 800)
plot(combined_stats$dist, combined_stats$ones_p_accum, type = "l", col = "aquamarine3",
lwd = 2, xlab = "Distance (km)", ylab = "Cumulative representative cells",
main = paste(name, year, model, sep = " - "))
lines(combined_stats$dist, combined_stats$ones_f_accum, col = "coral3", lwd = 2)
abline(h = max(combined_stats$ones_p_accum), lty = 2, lwd = 1.5)
legend("bottomright", legend = c("Present", "Future"),
col = c("aquamarine3", "coral3"), lwd = 2)
dev.off()
}
# Procesar todos los polígonos
for (j in seq_len(nrow(polygon))) {
process_polygon(j)
}
}
library(ggplot2)
library(terra)
library(sf)
library(tidyterra)
pp <- pa_mh_present_future(
present_climatic_variables,
future_climatic_variables,
polygon,
output_dir = dir_result,
model = "kkdvk",
year = "2070",
th = 0.9,
reference_system = "EPSG:4326" ,
study_area = NULL)
